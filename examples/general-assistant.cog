import "lib/exec.cog"
import "../lib/web_search.cog"

type Action:
    type: String
    task_name: String

flow shell(command: String) -> String:
    "Run a shell command. Output limited to 50 lines."
    return __exec_shell__(f"{command} | head -50")

flow read_file(path: String) -> String:
    "Read the contents of a file"
    return read(file(path))

flow write_file(path: String, content: String) -> String:
    "Write content to a file"
    write(file(path), content)
    return f"Wrote {content.length} chars to {path}"

flow do_task(description: String) -> String:
    "Execute a complex task in the background"
    # Step 1: Search the web for information
    write(stdout, f"  ğŸ“¡ Searching the web...\n")
    search_results = web_search(description)
    # Step 2: Ask LLM to synthesize
    write(stdout, f"  ğŸ§  Analyzing results...\n")
    response = think(
        f"Task: {description}\n\nWeb search results:\n{search_results}\n\nProvide a comprehensive summary based on these search results.",
        model="claude-sonnet-4-20250514",
        system="Synthesize the search results into a clear, well-structured summary. Include key findings, trends, and insights."
    )
    return response.content

flow handle_input(input: String, tasks: Map) -> Map:
    tools = ["shell", "read_file", "write_file", "web_search"]
    if input == "status":
        if tasks.length == 0:
            write(stdout, "No tasks running.\n")
        for name, handle in tasks:
            write(stdout, f"  â³ {name}: running\n")
        return tasks
    if input.starts_with("cancel "):
        name = input[7:].strip()
        try:
            cancel(tasks[name])
            tasks = remove(tasks, name)
            write(stdout, f"ğŸ›‘ Cancelled '{name}'.\n")
        catch err:
            write(stdout, f"No task named '{name}'.\n")
        return tasks
    # Simple keyword-based routing â€” no LLM needed for classification
    should_spawn = false
    task_name = "task"
    if input.contains("research") or input.contains("investigate") or input.contains("analyze") or input.contains("summarize") or input.contains("find out") or input.contains("look into") or input.contains("deep dive"):
        should_spawn = true
        if input.contains("research"):
            task_name = "research"
        if input.contains("analyze"):
            task_name = "analysis"
        if input.contains("investigate"):
            task_name = "investigation"
    if should_spawn:
        handle = async do_task(input)
        tasks[task_name] = handle
        write(stdout, f"âš¡ Started '{task_name}' in background. Keep talking.\n")
        return tasks
    write(stdout, "ğŸ” Thinking...\n")
    response = think(
        input,
        model="claude-sonnet-4-20250514",
        system="Be concise and helpful. You have tools available â€” use them when they can help answer the question. For date/time use shell('date'), for web info use web_search().",
        tools=tools
    )
    if response.has_tool_calls:
        write(stdout, "ğŸ”§ Using tools...\n")
        executed = exec(response, tools=tools)
        final = think(
            f"User asked: {input}\n\nTool results:\n{executed.content}\n\nAnswer the user's question based on these results.",
            model="claude-sonnet-4-20250514",
            system="Answer the user's question based on the tool results. Be concise."
        )
        write(stdout, f"{final.content}\n")
    else:
        write(stdout, f"{response.content}\n")
    return tasks

flow main():
    write(stdout, "ğŸ¤– Responsive Assistant\n")
    write(stdout, "Commands: status, cancel <name>, exit\n\n")
    tasks = {}
    loop:
        write(stdout, "> ")
        if tasks.length == 0:
            input = read(stdin)
            if input == "exit":
                break
            tasks = handle_input(input, tasks)
        else:
            select:
                branch:
                    input = read(stdin)
                    if input == "exit":
                        for name, handle in tasks:
                            cancel(handle)
                        break
                    tasks = handle_input(input, tasks)
                branch:
                    first_name = ""
                    first_handle = None
                    for name, handle in tasks:
                        if first_name == "":
                            first_name = name
                            first_handle = handle
                    result = await(first_handle)
                    write(stdout, f"\nâœ… Task '{first_name}' complete:\n{result}\n")
                    tasks = remove(tasks, first_name)
    write(stdout, "Goodbye! ğŸ‘‹\n")

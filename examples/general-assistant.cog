import "lib/exec.cog"
import "../lib/web_search.cog"

flow shell(command: String) -> String:
    "Run a shell command. Output limited to 50 lines."
    return __exec_shell__(f"{command} | head -50")

flow read_file(path: String) -> String:
    "Read the contents of a file"
    return read(file(path))

flow do_research(query: String) -> String:
    "Research a topic using web search + LLM synthesis"
    write(stdout, "  ğŸ“¡ Searching the web...\n")
    results = web_search(query, num_results=3)
    if results == "":
        return "Web search returned no results."
    write(stdout, "  ğŸ§  Synthesizing findings...\n")
    summary = think(f"Research query: {query}\n\nSearch results:\n{results}\n\nProvide a clear, structured summary.", model="claude-sonnet-4-20250514", system="Synthesize search results into a concise summary. Include key points and URLs.")
    return summary

flow classify_and_respond(input: String, tasks: Map) -> Map:
    "Classify user input and either respond or spawn a task"
    write(stdout, "ğŸ” Thinking...\n")
    classification = think(f"Does this request need web research or lengthy analysis? Answer ONLY 'yes' or 'no'.\n\nRequest: \"{input}\"", model="claude-sonnet-4-20250514")
    if classification.lower().contains("yes"):
        handle = async do_research(input)
        tasks["research"] = handle
        write(stdout, "âš¡ Started 'research' in background. Keep talking.\n")
        return tasks
    response = think(input, model="claude-sonnet-4-20250514", system="Be concise and helpful.", tools=["shell", "read_file"])
    if response.has_tool_calls:
        executed = exec(response, tools=["shell", "read_file"])
        final = think(f"User asked: {input}\nResults:\n{executed.content}", model="claude-sonnet-4-20250514", system="Answer concisely.")
        write(stdout, f"{final.content}\n")
    else:
        write(stdout, f"{response.content}\n")
    return tasks

flow quick_respond(input: String, tasks: Map):
    "Quick response while background tasks are running"
    task_names = []
    for name, handle in tasks:
        task_names = task_names + [name]
    write(stdout, "ğŸ” Thinking...\n")
    response = think(input, model="claude-sonnet-4-20250514", system=f"Be very concise (1-2 sentences). Background tasks running: {task_names}. If user asks about them, say they're still working.")
    write(stdout, f"{response}\n")

flow handle_command(input: String, tasks: Map) -> Map:
    "Handle status, cancel, and other commands"
    if input == "status":
        if tasks.length == 0:
            write(stdout, "No tasks running.\n")
        for name, handle in tasks:
            write(stdout, f"  â³ {name}: running\n")
        return tasks
    if input.starts_with("cancel "):
        name = input[7:].strip()
        try:
            cancel(tasks[name])
            tasks = remove(tasks, name)
            write(stdout, f"ğŸ›‘ Cancelled '{name}'.\n")
        catch err:
            write(stdout, f"No task named '{name}'.\n")
        return tasks
    return tasks

flow main():
    write(stdout, "ğŸ¤– Assistant ready.\n")
    write(stdout, "Type naturally. 'status' to check tasks, 'exit' to quit.\n\n")
    tasks = {}
    loop:
        write(stdout, "> ")
        if tasks.length == 0:
            input = read(stdin)
            if input == "exit" or input == "quit":
                break
            if input == "status":
                write(stdout, "No tasks running.\n")
            if input != "status":
                tasks = classify_and_respond(input, tasks)
        else:
            select:
                branch:
                    input = read(stdin)
                    if input == "exit" or input == "quit":
                        for name, handle in tasks:
                            cancel(handle)
                        break
                    if input == "status" or input.starts_with("cancel "):
                        tasks = handle_command(input, tasks)
                    if input != "status":
                        if input.starts_with("cancel ") == false:
                            quick_respond(input, tasks)
                branch:
                    first_name = ""
                    first_handle = None
                    for name, handle in tasks:
                        if first_name == "":
                            first_name = name
                            first_handle = handle
                    result = await(first_handle)
                    write(stdout, f"\nâœ… '{first_name}' complete:\n{result}\n")
                    tasks = remove(tasks, first_name)
    write(stdout, "Goodbye! ğŸ‘‹\n")

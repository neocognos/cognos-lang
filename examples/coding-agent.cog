# coding-agent.cog — Autonomous coding agent for resolving GitHub issues
# Run: cognos run --memory --allow-shell examples/coding-agent.cog
#
# Single-phase design: one tool loop handles explore → plan → edit → verify

import "lib/exec.cog"

# --- Tool flows (available to think()) ---

flow shell(command: String) -> String:
    "Run a shell command. Use for grep, sed, git, python3, etc."
    return __exec_shell__(command)

flow read_file(path: String) -> String:
    "Read a file. Path is relative to the repo root."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && cat {path}")

flow read_lines(path: String, start: Int, end: Int) -> String:
    "Read specific lines from a file (1-indexed)"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && sed -n '{start},{end}p' {path}")

flow search(pattern: String, path: String = ".") -> String:
    "Grep for a pattern in Python files. Returns matching lines with file:line prefix."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && grep -rnE '{pattern}' {path} --include='*.py' | head -50")

flow find_files(pattern: String) -> String:
    "Find files matching a glob pattern"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && find . -name '{pattern}' -not -path './.git/*' | head -30")

flow list_dir(path: String = ".") -> String:
    "List directory contents"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && ls -la {path}")

flow edit_file(path: String, old_text: String, new_text: String) -> String:
    "Replace old_text with new_text in a file. Use for surgical edits. old_text must match exactly."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    full_path = f"{repo}/{path}"
    # Save old/new text to temp files, use python3 for reliable replacement
    write_text("/tmp/cognos-old.txt", old_text)
    write_text("/tmp/cognos-new.txt", new_text)
    write_text("/tmp/cognos-edit.py", "import sys\nwith open(sys.argv[1]) as f: content = f.read()\nwith open('/tmp/cognos-old.txt') as f: old = f.read()\nwith open('/tmp/cognos-new.txt') as f: new = f.read()\nif old not in content: print('ERROR: old_text not found'); sys.exit(1)\ncontent = content.replace(old, new, 1)\nwith open(sys.argv[1], 'w') as f: f.write(content)\nprint('OK: edited ' + sys.argv[1])")
    return __exec_shell__(f"python3 /tmp/cognos-edit.py {full_path}")

flow git_diff() -> String:
    "Show current uncommitted changes as unified diff"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && git diff")

# --- Main agent ---

flow solve(issue: String, repo_path: String, test_cmd: String = "python3 -m pytest") -> String:
    "Solve a GitHub issue using a single tool loop"
    
    # Get repo structure for initial context
    dirs = shell(f"cd {repo_path} && find . -maxdepth 2 -type f -name '*.py' | head -30")
    top = shell(f"cd {repo_path} && ls -la")
    
    system_prompt = f"You are an expert software engineer fixing a bug in a Python repository.\n\nRepository: {repo_path}\nTop-level files:\n{top}\n\nPython files:\n{dirs}\n\nYOUR TASK: Fix the bug described below. You have LIMITED turns — be efficient!\n\nSTRATEGY (follow this order strictly):\n1. SEARCH (2-3 turns max): Use search() to find the relevant code\n2. READ (1-2 turns): Use read_lines() to understand the buggy code\n3. EDIT (1 turn): Use edit_file(path, old_text, new_text) to fix it\n4. VERIFY (1 turn): Use git_diff() to confirm your fix\n\nCRITICAL RULES:\n- You MUST call edit_file() by turn 6 at the latest. Do NOT keep searching forever.\n- If you have a reasonable hypothesis after 3-4 searches, START EDITING immediately.\n- Use read_lines() for specific sections (20-50 lines), never read whole files.\n- old_text in edit_file must match the file EXACTLY (copy from read_lines output).\n- After editing, ALWAYS call git_diff() to verify.\n- When done, say DONE and summarize what you changed.\n- If edit_file fails (old_text not found), re-read the exact lines and try again.\n\nBug report:\n{issue}"

    r = think(
        f"Find and fix this bug. Search for relevant code (2-3 turns), then edit_file() to fix it, then git_diff() to verify. You MUST edit by turn 6.\n\nBug report:\n{issue}",
        model="claude-sonnet-4-20250514",
        tools=["shell", "read_file", "read_lines", "search", "find_files", "list_dir", "edit_file", "git_diff"],
        system=system_prompt
    )
    
    if r.has_tool_calls:
        result = exec(r, 
            tools=["shell", "read_file", "read_lines", "search", "find_files", "list_dir", "edit_file", "git_diff"],
            model="claude-sonnet-4-20250514",
            max_turns=20,
            system=system_prompt
        )
    
    # Get final diff
    diff = shell(f"cd {repo_path} && git diff")
    return diff

flow main():
    issue = shell("cat /tmp/cognos-issue.txt 2>/dev/null")
    repo_path = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    
    if issue.strip() == "":
        write(stdout, "Enter issue (Ctrl+D to end):")
        issue = read(stdin)
        if issue == none:
            return none
        write(stdout, "Enter repo path:")
        repo_path = read(stdin)
        if repo_path == none:
            repo_path = "."
        repo_path = repo_path.strip()
    
    write(stdout, f"Solving issue in {repo_path}...")
    
    diff = solve(issue, repo_path)
    
    write(stdout, "\n--- PATCH ---")
    write(stdout, diff)
    write(stdout, "--- END PATCH ---")

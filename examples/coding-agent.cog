# coding-agent.cog — Autonomous coding agent for resolving GitHub issues
# Run: cognos run --memory --allow-shell examples/coding-agent.cog
#
# Input: issue description via stdin or params
# Output: unified diff patch to stdout

import "lib/exec.cog"

# --- Tool flows (available to think()) ---

flow shell(command: String) -> String:
    "Run a shell command in the repository"
    return __exec_shell__(command)

flow read_file(path: String) -> String:
    "Read a file from the repository. Path can be relative (resolved from repo root) or absolute."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && cat {path}")

flow read_lines(path: String, start: Int, end: Int) -> String:
    "Read specific lines from a file (sed)"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && sed -n '{start},{end}p' {path}")

flow search(pattern: String, path: String = ".") -> String:
    "Search for a pattern in code files (grep -rn)"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && grep -rn '{pattern}' {path} --include='*.py' | head -40")

flow find_files(pattern: String) -> String:
    "Find files matching a pattern"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && find . -name '{pattern}' -not -path './.git/*' | head -30")

flow list_dir(path: String = ".") -> String:
    "List directory contents"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && ls -la {path}")

flow run_test(test_cmd: String) -> String:
    "Run a test command and return output"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && {test_cmd} 2>&1 | tail -50")

flow apply_patch(patch: String) -> String:
    "Apply a patch using heredoc"
    save("/tmp/cognos-patch.diff", patch)
    return __exec_shell__("cd /tmp && cat cognos-patch.diff")

flow write_file(path: String, content: String) -> String:
    "Write content to a file. For code edits, prefer using shell() with sed or python3 -c instead."
    save(path, content)
    return f"Wrote {path}"

flow git_diff() -> String:
    "Show current uncommitted changes as unified diff"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && git diff")

# --- Agent logic ---

flow explore(repo_path: String, issue: String) -> String:
    "Explore the repo to understand its structure and find relevant code"
    # Get repo structure
    structure = shell(f"cd {repo_path} && find . -name '*.py' -not -path './.git/*' -not -path './.tox/*' -not -path './build/*' | head -50")
    remember(f"Repo structure: {structure}")

    # Ask LLM to identify relevant files
    r = think(
        f"Given this repo structure:\n{structure}\n\nAnd this issue:\n{issue}\n\nWhich files are most likely relevant? List the top 5 file paths.",
        model="deepseek-chat"
    )
    remember(f"Relevant files: {r.content}")

    # Read the relevant files
    files = r.content
    r2 = think(
        f"Files identified as relevant:\n{files}\n\nI need to read these files to understand the code. Which file should I read first?",
        model="deepseek-chat",
        tools=["read_file", "search", "read_lines"],
        system="Read the most relevant files to understand the bug. Use tools."
    )
    if r2.has_tool_calls:
        result = exec(r2, tools=["read_file", "search", "read_lines"])
        remember(f"Code exploration: {result.content}")
    
    return "Exploration complete"

flow plan_fix(issue: String) -> String:
    "Plan the fix based on what we know"
    knowledge = recall(issue, limit=10)
    
    context = "What we know:\n"
    for fact in knowledge:
        context = context + f"- {fact}\n"
    
    r = think(
        f"{context}\nIssue to fix:\n{issue}\n\nPlan a minimal, targeted fix. Describe exactly which file(s) to edit, what to change, and why.",
        model="deepseek-chat",
        system="You are an expert software engineer. Plan the smallest possible fix that resolves the issue without side effects. Be specific about file paths and line numbers."
    )
    
    plan = r.content
    remember(f"Fix plan: {plan}")
    return plan

flow implement_fix(plan: String, repo_path: String) -> String:
    "Implement the planned fix by reading code and applying edits"
    knowledge = recall(plan, limit=5)
    
    context = "Relevant context:\n"
    for fact in knowledge:
        context = context + f"- {fact}\n"
    
    # Step 1: Read the files that need editing
    r1 = think(
        f"{context}\nFix plan:\n{plan}\n\nWhich files do I need to read to implement this fix? Use read_file or read_lines to examine them.",
        model="deepseek-chat",
        tools=["read_file", "read_lines", "search"],
        system="Read the files needed for the fix. Do NOT edit yet, just read."
    )
    
    file_contents = ""
    if r1.has_tool_calls:
        result = exec(r1, tools=["read_file", "read_lines", "search"])
        file_contents = result.content
    
    # Step 2: Generate the exact edit as a shell command
    r2 = think(
        f"{context}\nFile contents:\n{file_contents}\n\nFix plan:\n{plan}\n\nWrite a shell command using python3 -c or sed -i to apply the fix. The command must edit the file IN PLACE. Output ONLY the shell command, nothing else.",
        model="deepseek-chat",
        system="You are a coding agent. Output ONLY a shell command that applies the fix. Use python3 -c with open/read/write/replace for complex edits, or sed -i for simple ones. No explanation, no markdown, no code fences. Just the raw command."
    )
    
    edit_cmd = r2.content.strip()
    
    # Step 3: Apply the edit
    result = shell(f"cd {repo_path} && {edit_cmd}")
    remember(f"Applied edit: {edit_cmd}")
    remember(f"Edit result: {result}")
    
    # Verify the edit took effect
    diff = shell(f"cd {repo_path} && git diff --stat")
    remember(f"Files changed: {diff}")
    
    return f"Edit applied. Changes: {diff}"

flow verify(repo_path: String, test_cmd: String) -> Map:
    "Run tests and return pass/fail with output"
    output = shell(f"cd {repo_path} && {test_cmd} 2>&1 | tail -30")
    
    r = think(
        f"Test output:\n{output}\n\nDid the tests pass? Reply with ONLY 'PASS' or 'FAIL: <reason>'",
        model="deepseek-chat"
    )
    
    passed = r.content.strip().starts_with("PASS")
    return {"passed": passed, "output": output, "summary": r.content}

flow self_correct(error: String, attempt: Int, issue: String, repo_path: String) -> String:
    "Analyze test failure and try a different approach"
    # Recall what we've tried before
    past_attempts = recall("attempt failed", limit=5)
    
    context = f"Test failure (attempt {attempt}):\n{error}\n\n"
    if past_attempts.length > 0:
        context = context + "Previous failed attempts:\n"
        for attempt_info in past_attempts:
            context = context + f"- {attempt_info}\n"
        context = context + "\nDo NOT repeat these approaches.\n\n"
    
    r = think(
        f"{context}Original issue:\n{issue}\n\nAnalyze why the fix failed and propose a DIFFERENT approach.",
        model="deepseek-chat",
        tools=["read_file", "search", "shell", "read_lines"],
        system="You are debugging a failed fix. Read the relevant code, understand why it failed, and propose a different strategy. Do NOT repeat previous attempts."
    )
    
    if r.has_tool_calls:
        result = exec(r, tools=["read_file", "search", "shell", "read_lines"])
        new_plan = result.content
    else:
        new_plan = r.content
    
    remember(f"Attempt {attempt} failed: {error}. New plan: {new_plan}")
    return new_plan

flow solve(issue: String, repo_path: String, test_cmd: String = "python3 -m pytest", max_attempts: Int = 3) -> String:
    "Solve a GitHub issue: explore → plan → implement → verify → self-correct"
    
    # Phase 1: Explore
    explore(repo_path, issue)
    
    # Phase 2: Plan
    plan = plan_fix(issue)
    
    # Phase 3: Implement + verify loop
    attempt = 1
    loop:
        if attempt > max_attempts:
            write(stdout, "Max attempts reached. Returning best-effort patch.")
            break
        
        # Implement
        implement_fix(plan, repo_path)
        
        # Verify
        result = verify(repo_path, test_cmd)
        
        if result.passed:
            remember(f"Fix verified on attempt {attempt}")
            break
        
        # Self-correct
        remember(f"Attempt {attempt} failed: {result.summary}")
        plan = self_correct(result.output, attempt, issue, repo_path)
        attempt = attempt + 1
    
    # Generate diff
    diff = shell(f"cd {repo_path} && git diff")
    return diff

flow main():
    # Read issue from /tmp/cognos-issue.txt, repo path from /tmp/cognos-repo.txt
    # (Set by wrapper script before running)
    issue = shell("cat /tmp/cognos-issue.txt 2>/dev/null")
    repo_path = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    
    if issue.strip() == "":
        # Fallback: interactive mode
        write(stdout, "Enter issue (Ctrl+D to end):")
        issue = read(stdin)
        if issue == none:
            return none
        write(stdout, "Enter repo path:")
        repo_path = read(stdin)
        if repo_path == none:
            repo_path = "."
        repo_path = repo_path.strip()
    
    write(stdout, f"Solving issue in {repo_path}...")
    
    diff = solve(issue, repo_path)
    
    write(stdout, "\n--- PATCH ---")
    write(stdout, diff)
    write(stdout, "--- END PATCH ---")

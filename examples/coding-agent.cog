# coding-agent.cog — Autonomous coding agent for resolving GitHub issues
# Run: cognos run --memory --allow-shell examples/coding-agent.cog
#
# Input: issue description via stdin or params
# Output: unified diff patch to stdout

import "lib/exec.cog"

# --- Tool flows (available to think()) ---

flow shell(command: String) -> String:
    "Run a shell command in the repository"
    return __exec_shell__(command)

flow read_file(path: String) -> String:
    "Read a file from the repository. Path can be relative (resolved from repo root) or absolute."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && cat {path}")

flow read_lines(path: String, start: Int, end: Int) -> String:
    "Read specific lines from a file (sed)"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && sed -n '{start},{end}p' {path}")

flow search(pattern: String, path: String = ".") -> String:
    "Search for a pattern in code files (grep -rn)"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && grep -rn '{pattern}' {path} --include='*.py' | head -40")

flow find_files(pattern: String) -> String:
    "Find files matching a pattern"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && find . -name '{pattern}' -not -path './.git/*' | head -30")

flow list_dir(path: String = ".") -> String:
    "List directory contents"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && ls -la {path}")

flow run_test(test_cmd: String) -> String:
    "Run a test command and return output"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && {test_cmd} 2>&1 | tail -50")

flow apply_patch(patch: String) -> String:
    "Apply a patch using heredoc"
    save("/tmp/cognos-patch.diff", patch)
    return __exec_shell__("cd /tmp && cat cognos-patch.diff")

flow write_file(path: String, content: String) -> String:
    "Write raw text content to a file. Use for creating or overwriting files."
    write_text(path, content)
    return f"Wrote {path}"

flow git_diff() -> String:
    "Show current uncommitted changes as unified diff"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && git diff")

# --- Agent logic ---

flow explore(repo_path: String, issue: String) -> String:
    "Explore the repo to find relevant code for the issue"
    # Get high-level structure (directories only, then grep for keywords)
    dirs = shell(f"cd {repo_path} && find . -maxdepth 3 -type d -not -path './.git/*' | head -40")
    
    # Also get top-level files for context
    top_files = shell(f"cd {repo_path} && ls -la")
    
    # Extract key terms from issue for grep
    r = think(
        f"Issue:\n{issue}\n\nRepo root ({repo_path}):\n{top_files}\n\nRepo directories:\n{dirs}\n\nIdentify: 1) Which directory contains the relevant code? 2) What function/class names should I search for? Use the search tool to find them.",
        model="deepseek-chat",
        tools=["search", "find_files", "read_file", "read_lines"],
        system=f"You are working in repo at {repo_path}. Find the relevant source files for this bug. Use search() to grep for key function names mentioned in the issue. Use read_file to examine the most relevant file. Be efficient — read only what you need."
    )
    
    if r.has_tool_calls:
        result = exec(r, tools=["search", "find_files", "read_file", "read_lines"], system=f"You are working in repo at {repo_path}. Issue: {issue}\n\nFind the relevant source files for this bug. Use search() and read_file() to examine code. Be efficient.")
        remember(f"Exploration findings: {result.content}")
    else:
        remember(f"Exploration analysis: {r.content}")
    
    return "Exploration complete"

flow plan_fix(issue: String) -> String:
    "Plan the fix based on what we know"
    knowledge = recall(issue, limit=10)
    
    context = "What we know:\n"
    for fact in knowledge:
        context = context + f"- {fact}\n"
    
    r = think(
        f"{context}\nIssue to fix:\n{issue}\n\nPlan a minimal, targeted fix. Describe exactly which file(s) to edit, what to change, and why.",
        model="deepseek-chat",
        tools=["read_file", "read_lines", "search"],
        system="You are an expert software engineer. Plan the smallest possible fix that resolves the issue without side effects. Be specific about file paths and line numbers. Read the relevant code to confirm your plan before finalizing."
    )
    
    if r.has_tool_calls:
        result = exec(r, tools=["read_file", "read_lines", "search"], system="You are an expert software engineer. Plan the smallest possible fix. Be specific about file paths and line numbers.")
        plan = result.content
    else:
        plan = r.content
    remember(f"Fix plan: {plan}")
    return plan

flow implement_fix(plan: String, repo_path: String) -> String:
    "Implement the planned fix: read file, generate fixed version, write it back"
    knowledge = recall(plan, limit=5)
    
    context = "Relevant context:\n"
    for fact in knowledge:
        context = context + f"- {fact}\n"
    
    # Step 1: Read the file that needs editing (DeepSeek for better code understanding)
    r1 = think(
        f"{context}\nFix plan:\n{plan}\n\nRead the file that needs to be fixed. Use read_file or read_lines with the exact path.",
        model="deepseek-chat",
        tools=["read_file", "read_lines", "search"],
        system=f"You are working in repo at {repo_path}. Read the file that needs fixing. Be precise — use the file paths from the fix plan."
    )
    
    file_contents = ""
    if r1.has_tool_calls:
        result = exec(r1, tools=["read_file", "read_lines", "search"], model="deepseek-chat", system=f"You are working in repo at {repo_path}. Fix plan:\n{plan}\n\nRead the file that needs fixing based on this plan.")
        file_contents = result.content
    
    # Step 2: Apply the fix (DeepSeek for reliable code edits)
    r2 = think(
        f"{context}\nCurrent file contents:\n{file_contents}\n\nFix plan:\n{plan}\n\nApply the fix now. Use shell() with sed -i or python3 to edit the file. For multi-line edits, write a python3 script to /tmp/fix.py then run it.",
        model="deepseek-chat",
        tools=["shell", "read_file", "write_file"],
        system=f"You are an expert coder working in {repo_path}. Apply the fix using shell(). For simple changes use sed -i. For complex changes write a python3 script to /tmp/fix.py and run it. ALWAYS verify with shell('cd {repo_path} && git diff') after editing."
    )
    
    if r2.has_tool_calls:
        result = exec(r2, tools=["shell", "read_file", "write_file"], model="deepseek-chat", system=f"Apply the fix in {repo_path}. Fix plan:\n{plan}\n\nUse shell() with sed -i or python3 to edit files. Verify with shell('cd {repo_path} && git diff') after.")
        remember(f"Implementation result: {result.content}")
    
    # Check if changes were made
    diff = shell(f"cd {repo_path} && git diff --stat")
    remember(f"Files changed: {diff}")
    
    return f"Changes: {diff}"

flow verify(repo_path: String, test_cmd: String) -> Map:
    "Run tests and return pass/fail with output"
    # First check if test dependencies are available
    dep_check = shell(f"cd {repo_path} && python3 -c 'import pytest' 2>&1")
    if dep_check.contains("ModuleNotFoundError"):
        # Try installing test deps
        shell(f"cd {repo_path} && pip install -e '.[test]' 2>/dev/null; pip install -e '.[dev]' 2>/dev/null; pip install pytest 2>/dev/null")
    
    output = shell(f"cd {repo_path} && {test_cmd} 2>&1 | tail -50")
    
    # Check for import errors / missing deps — treat as inconclusive, not failure
    if output.contains("ModuleNotFoundError") or output.contains("ImportError"):
        # Verify our specific change didn't break anything by checking syntax
        syntax_check = shell(f"cd {repo_path} && git diff --name-only | xargs -I{{}} python3 -c \"import py_compile; py_compile.compile('{{}}', doraise=True)\" 2>&1")
        if syntax_check.contains("Error"):
            return {"passed": false, "output": syntax_check, "summary": "FAIL: syntax error in changed files"}
        return {"passed": true, "output": output, "summary": "PASS (deps missing, syntax OK)"}
    
    r = think(
        f"Test output:\n{output}\n\nDid the tests pass? Reply with ONLY 'PASS' or 'FAIL: <reason>'",
        model="deepseek-chat"
    )
    
    passed = r.content.strip().starts_with("PASS")
    return {"passed": passed, "output": output, "summary": r.content}

flow self_correct(error: String, attempt: Int, issue: String, repo_path: String) -> String:
    "Analyze test failure and try a different approach"
    # Recall what we've tried before
    past_attempts = recall("attempt failed", limit=5)
    
    context = f"Test failure (attempt {attempt}):\n{error}\n\n"
    if past_attempts.length > 0:
        context = context + "Previous failed attempts:\n"
        for attempt_info in past_attempts:
            context = context + f"- {attempt_info}\n"
        context = context + "\nDo NOT repeat these approaches.\n\n"
    
    r = think(
        f"{context}Original issue:\n{issue}\n\nAnalyze why the fix failed and propose a DIFFERENT approach.",
        model="deepseek-chat",
        tools=["read_file", "search", "shell", "read_lines"],
        system=f"You are debugging a failed fix in {repo_path}. Read the relevant code, understand why it failed, and propose a different strategy. Do NOT repeat previous attempts."
    )
    
    if r.has_tool_calls:
        result = exec(r, tools=["read_file", "search", "shell", "read_lines"], system=f"You are debugging a failed fix in {repo_path}. Read code, understand the failure, propose a different strategy.")
        new_plan = result.content
    else:
        new_plan = r.content
    
    remember(f"Attempt {attempt} failed: {error}. New plan: {new_plan}")
    return new_plan

flow solve(issue: String, repo_path: String, test_cmd: String = "python3 -m pytest", max_attempts: Int = 3) -> String:
    "Solve a GitHub issue: explore → plan → implement → verify → self-correct"
    
    # Phase 1: Explore
    explore(repo_path, issue)
    
    # Phase 2: Plan
    plan = plan_fix(issue)
    
    # Phase 3: Implement + verify loop
    attempt = 1
    loop:
        if attempt > max_attempts:
            write(stdout, "Max attempts reached. Returning best-effort patch.")
            break
        
        # Implement
        implement_fix(plan, repo_path)
        
        # Verify
        result = verify(repo_path, test_cmd)
        
        if result.passed:
            remember(f"Fix verified on attempt {attempt}")
            break
        
        # Self-correct
        remember(f"Attempt {attempt} failed: {result.summary}")
        plan = self_correct(result.output, attempt, issue, repo_path)
        attempt = attempt + 1
    
    # Generate diff
    diff = shell(f"cd {repo_path} && git diff")
    return diff

flow main():
    # Read issue from /tmp/cognos-issue.txt, repo path from /tmp/cognos-repo.txt
    # (Set by wrapper script before running)
    issue = shell("cat /tmp/cognos-issue.txt 2>/dev/null")
    repo_path = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    
    if issue.strip() == "":
        # Fallback: interactive mode
        write(stdout, "Enter issue (Ctrl+D to end):")
        issue = read(stdin)
        if issue == none:
            return none
        write(stdout, "Enter repo path:")
        repo_path = read(stdin)
        if repo_path == none:
            repo_path = "."
        repo_path = repo_path.strip()
    
    write(stdout, f"Solving issue in {repo_path}...")
    
    diff = solve(issue, repo_path)
    
    write(stdout, "\n--- PATCH ---")
    write(stdout, diff)
    write(stdout, "--- END PATCH ---")

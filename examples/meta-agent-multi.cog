# meta-agent-multi.cog — Multi-step meta-agent: decomposes complex tasks into sub-flows
# Run: cognos run --memory --allow-shell examples/meta-agent-multi.cog

import "lib/exec.cog"

# --- Tool flows available to generated code ---

flow shell(command: String) -> String:
    "Run a shell command."
    return __exec_shell__(command)

flow read_file(path: String) -> String:
    "Read a file. Path is relative to the repo root."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && cat {path}")

flow read_lines(path: String, start: Int, end: Int) -> String:
    "Read specific lines from a file (1-indexed)"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && sed -n '{start},{end}p' {path}")

flow search(pattern: String, path: String = ".") -> String:
    "Grep for a pattern in Python files."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && grep -rnE '{pattern}' {path} --include='*.py' | head -50")

flow find_files(pattern: String) -> String:
    "Find files matching a glob pattern"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && find . -name '{pattern}' -not -path './.git/*' | head -30")

flow list_dir(path: String = ".") -> String:
    "List directory contents"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && ls -la {path}")

flow edit_file(path: String, old_text: String, new_text: String) -> String:
    "Replace old_text with new_text in a file. old_text must match exactly."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    if path[:1] == "/":
        full_path = path
    else:
        full_path = f"{repo}/{path}"
    write_text("/tmp/cognos-old.txt", old_text)
    write_text("/tmp/cognos-new.txt", new_text)
    write_text("/tmp/cognos-edit.py", "import sys\nwith open(sys.argv[1]) as f: content = f.read()\nwith open('/tmp/cognos-old.txt') as f: old = f.read()\nwith open('/tmp/cognos-new.txt') as f: new = f.read()\nif old not in content:\n    print('ERROR: old_text not found in ' + sys.argv[1] + ' | Looking for: ' + repr(old[:200]))\nelse:\n    content = content.replace(old, new, 1)\n    with open(sys.argv[1], 'w') as f: f.write(content)\n    print('OK: edited ' + sys.argv[1])")
    result = __exec_shell__(f"python3 /tmp/cognos-edit.py {full_path}")
    if "ERROR" in result:
        log(f"edit_file failed: {result}")
    return result

flow git_diff() -> String:
    "Show current uncommitted changes as unified diff"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && git diff")

flow note(key: String, value: String) -> String:
    "Store a note for later reference"
    remember(f"{key}: {value}")
    return f"Noted: {key}"

flow strip_fences(code: String) -> String:
    "Strip markdown fences from generated code"
    if "```" in code:
        lines = code.split("\n")
        clean = []
        for line in lines:
            if line.strip()[:3] != "```":
                clean = clean + [line]
        return "\n".join(clean)
    return code

flow execute_with_retry(code: String, flow_name: String, grammar: String, max_attempts: Int = 3) -> Map:
    "Execute generated code with retry on failure. Returns {success: Bool, result: String, code: String}"
    current_code = code
    attempt = 0
    loop:
        if attempt >= max_attempts:
            return {"success": false, "result": "All attempts failed", "code": current_code}
        attempt = attempt + 1
        write(stdout, f"  Attempt {attempt}/{max_attempts} for {flow_name}...")
        try:
            eval(current_code)
            result = invoke(flow_name, {})
            return {"success": true, "result": str(result), "code": current_code}
        catch e:
            error_msg = f"{e}"
            write(stdout, f"  Failed: {error_msg}")
            if attempt < max_attempts:
                repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
                shell(f"cd {repo} && git checkout -- .")
                retry_prompt = f"Your Cognos flow '{flow_name}' failed:\n\n{error_msg}\n\nOriginal code:\n{current_code}\n\nFix and return ONLY the corrected Cognos source. No markdown fences."
                fix = think(retry_prompt, system=grammar, model="claude-opus-4-6")
                current_code = strip_fences(fix["content"])

# --- Multi-step orchestrator ---

flow main():
    issue = shell("cat /tmp/cognos-issue.txt 2>/dev/null")
    repo_path = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    
    if issue.strip() == "":
        write(stdout, "Enter issue (Ctrl+D to end):")
        issue = read(stdin)
        if issue == none:
            return none
        write(stdout, "Enter repo path:")
        repo_path = read(stdin)
        if repo_path == none:
            repo_path = "."
        repo_path = repo_path.strip()
    
    grammar = read_text("prompts/cognos-flow-generator.md")
    dirs = shell(f"cd {repo_path} && find . -maxdepth 3 -type f -name '*.py' | head -40")
    top = shell(f"cd {repo_path} && ls -la")
    
    # --- Phase 1: Task analysis and decomposition ---
    write(stdout, "Phase 1: Analyzing task complexity...")
    
    decompose_prompt = f"""Analyze this task and decide the approach:

Task: {issue}

Repo structure:
{top}

Python files:
{dirs}

Respond in EXACTLY this format (no markdown):
COMPLEXITY: simple | multi-step
PLAN:
- step 1 description
- step 2 description
...

Rules:
- "simple" = single logical change (one file, one concept)
- "multi-step" = requires investigation THEN separate changes, OR multiple files/concepts
- Keep steps to 2-4 max. Each step should produce a testable change.
- Each step description should be specific and actionable."""
    
    analysis = think(decompose_prompt, model="claude-sonnet-4-20250514")
    analysis_text = analysis["content"]
    write(stdout, f"\n{analysis_text}\n")
    
    # Parse complexity
    is_multi = "COMPLEXITY: multi-step" in analysis_text
    
    # Parse steps
    steps = []
    in_plan = false
    for line in analysis_text.split("\n"):
        if line.strip() == "PLAN:":
            in_plan = true
        elif in_plan and line.strip()[:2] == "- ":
            steps = steps + [line.strip()[2:]]
    
    if steps.length == 0:
        steps = ["Fix the issue as described"]
        is_multi = false
    
    # --- Check for cached flows ---
    cached_flow = ""
    prior = recall(f"cognos-flow: {issue[:200]}")
    if prior != none:
        if prior.strip() != "":
            write(stdout, "Found cached flow from similar task.")
            cached_flow = prior
    
    cache_hint = ""
    if cached_flow != "":
        cache_hint = f"\n\nPreviously successful flow for similar task — adapt, don't copy:\n{cached_flow}\n"
    
    if is_multi == false:
        # --- Simple mode: single flow (same as original meta-agent) ---
        write(stdout, f"\nSimple task — generating single flow...")
        
        gen_prompt = f"Write a Cognos flow called `solve` that fixes this bug.{cache_hint}\n\nCritical rules:\n- flow solve() -> String: (no parameters)\n- Do NOT use import — all tools are already available\n- think() ALWAYS returns a Map — use result[\"content\"] to get the string\n- ALWAYS pass model=\"claude-sonnet-4-20250514\" to think()\n- edit_file(path, old_text, new_text) — old_text must match EXACTLY. path is ABSOLUTE.\n- NEVER hardcode old_text from the bug report — always read_lines first\n- End with: return git_diff()\n- Repo path: {repo_path}\n\nPython files:\n{dirs}\n\nBug report:\n{issue}\n\nReturn ONLY the Cognos flow source code."
        
        result = think(gen_prompt, system=grammar, model="claude-opus-4-6")
        code = strip_fences(result["content"])
        write_text("/tmp/cognos-generated-flow.cog", code)
        write(stdout, "\n--- Generated Flow ---")
        write(stdout, code)
        write(stdout, "--- End ---\n")
        
        outcome = execute_with_retry(code, "solve", grammar)
        if outcome["success"]:
            write(stdout, "\n--- PATCH ---")
            write(stdout, outcome["result"])
            write(stdout, "--- END PATCH ---")
            summary = issue[:200].replace("\n", " ")
            remember(f"cognos-flow: {summary}\n---\n{outcome['code']}")
        else:
            write(stdout, "Failed to solve.")
    else:
        # --- Multi-step mode: generate and execute sub-flows sequentially ---
        write(stdout, f"\nMulti-step task — {steps.length} phases:")
        idx = 0
        for s in steps:
            idx = idx + 1
            write(stdout, f"  {idx}. {s}")
        
        all_context = ""
        step_num = 0
        
        for step in steps:
            step_num = step_num + 1
            sep = "=" * 50
            write(stdout, f"\n{sep}")
            write(stdout, f"Step {step_num}/{steps.length}: {step}")
            write(stdout, sep)
            
            # Get current state of the repo (may have changed from prior steps)
            current_diff = shell(f"cd {repo_path} && git diff --stat")
            
            # Generate a flow for this specific step
            step_flow_name = f"step_{step_num}"
            
            prev_changes = "No changes applied yet."
            if current_diff.strip() != "":
                prev_changes = f"Previous steps already applied these changes:\n{current_diff}"
            
            prev_context = ""
            if all_context != "":
                prev_context = f"Context from previous steps:\n{all_context}"
            
            step_prompt = f"""Write a Cognos flow called `{step_flow_name}` for this specific step of a larger task.{cache_hint}

Overall task: {issue}

This is step {step_num} of {steps.length}.
Current step: {step}

{prev_changes}

{prev_context}

Critical rules:
- flow {step_flow_name}() -> String: (no parameters)
- Do NOT use import — all tools are already available
- think() ALWAYS returns a Map — use result["content"] to get the string
- ALWAYS pass model="claude-sonnet-4-20250514" to think()
- edit_file(path, old_text, new_text) — old_text must match EXACTLY. path is ABSOLUTE.
- NEVER hardcode old_text — always read_lines first to get exact current content
- Return a brief summary of what was done (String)
- Repo path: {repo_path}

Python files:
{dirs}

Return ONLY the Cognos flow source code."""
            
            result = think(step_prompt, system=grammar, model="claude-opus-4-6")
            code = strip_fences(result["content"])
            write_text(f"/tmp/cognos-step-{step_num}.cog", code)
            write(stdout, f"\n--- Step {step_num} Flow ---")
            write(stdout, code)
            write(stdout, "--- End ---\n")
            
            outcome = execute_with_retry(code, step_flow_name, grammar)
            
            if outcome["success"]:
                write(stdout, f"Step {step_num} completed: {outcome['result'][:200]}")
                all_context = all_context + f"\nStep {step_num} ({step}): {outcome['result'][:300]}"
            else:
                write(stdout, f"Step {step_num} FAILED — stopping pipeline.")
                break
        
        # Final result
        diff = shell(f"cd {repo_path} && git diff")
        if diff.strip() != "":
            write(stdout, "\n--- PATCH ---")
            write(stdout, diff)
            write(stdout, "--- END PATCH ---")
            summary = issue[:200].replace("\n", " ")
            remember(f"cognos-multi-flow: {summary}\n---\nSteps: {steps.length}\n{all_context}")
            write(stdout, "Multi-step solution cached in memory.")
        else:
            write(stdout, "No changes produced.")

# meta-agent-multi.cog — Multi-step meta-agent: decomposes complex tasks into sub-flows
# Run: cognos run --memory --allow-shell examples/meta-agent-multi.cog

import "lib/exec.cog"

# --- Tool flows available to generated code ---

flow shell(command: String) -> String:
    "Run a shell command."
    return __exec_shell__(command)

flow read_file(path: String) -> String:
    "Read a file. Path is relative to the repo root."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && cat {path}")

flow read_lines(path: String, start: Int, end: Int) -> String:
    "Read specific lines from a file (1-indexed)"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && sed -n '{start},{end}p' {path}")

flow search(pattern: String, path: String = ".") -> String:
    "Grep for a pattern in Python files."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && grep -rnE '{pattern}' {path} --include='*.py' | head -50")

flow find_files(pattern: String) -> String:
    "Find files matching a glob pattern"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && find . -name '{pattern}' -not -path './.git/*' | head -30")

flow list_dir(path: String = ".") -> String:
    "List directory contents"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && ls -la {path}")

flow edit_file(path: String, old_text: String, new_text: String) -> String:
    "Replace old_text with new_text in a file. old_text must match exactly."
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    if path[:1] == "/":
        full_path = path
    else:
        full_path = f"{repo}/{path}"
    write_text("/tmp/cognos-old.txt", old_text)
    write_text("/tmp/cognos-new.txt", new_text)
    write_text("/tmp/cognos-edit.py", "import sys\nwith open(sys.argv[1]) as f: content = f.read()\nwith open('/tmp/cognos-old.txt') as f: old = f.read()\nwith open('/tmp/cognos-new.txt') as f: new = f.read()\nif old not in content:\n    print('ERROR: old_text not found in ' + sys.argv[1] + ' | Looking for: ' + repr(old[:200]))\nelse:\n    content = content.replace(old, new, 1)\n    with open(sys.argv[1], 'w') as f: f.write(content)\n    print('OK: edited ' + sys.argv[1])")
    result = __exec_shell__(f"python3 /tmp/cognos-edit.py {full_path}")
    if "ERROR" in result:
        log(f"edit_file failed: {result}")
    return result

flow git_diff() -> String:
    "Show current uncommitted changes as unified diff"
    repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    return __exec_shell__(f"cd {repo} && git diff")

flow note(key: String, value: String) -> String:
    "Store a note for later reference"
    remember(f"{key}: {value}")
    return f"Noted: {key}"

flow strip_fences(code: String) -> String:
    "Strip markdown fences from generated code"
    if "```" in code:
        lines = code.split("\n")
        clean = []
        for line in lines:
            if line.strip()[:3] != "```":
                clean = clean + [line]
        return clean.join("\n")
    return code

flow execute_with_retry(code: String, flow_name: String, grammar: String, max_attempts: Int = 3) -> Map:
    "Execute generated code with retry on failure. Returns {success: Bool, result: String, code: String}"
    current_code = code
    attempt = 0
    loop:
        if attempt >= max_attempts:
            return {"success": false, "result": "All attempts failed", "code": current_code}
        attempt = attempt + 1
        write(stdout, f"  Attempt {attempt}/{max_attempts} for {flow_name}...")
        try:
            eval(current_code)
            result = invoke(flow_name, {})
            return {"success": true, "result": str(result), "code": current_code}
        catch e:
            error_msg = f"{e}"
            write(stdout, f"  Failed: {error_msg}")
            if attempt < max_attempts:
                repo = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
                shell(f"cd {repo} && git checkout -- .")
                retry_prompt = f"Your Cognos flow '{flow_name}' failed:\n\n{error_msg}\n\nOriginal code:\n{current_code}\n\nFix and return ONLY the corrected Cognos source. No markdown fences."
                current_code = strip_fences(think(retry_prompt, system=grammar, model="claude-opus-4-6"))

# --- Multi-step orchestrator ---

flow main():
    issue = shell("cat /tmp/cognos-issue.txt 2>/dev/null")
    repo_path = shell("cat /tmp/cognos-repo.txt 2>/dev/null || echo '.'").strip()
    
    if issue.strip() == "":
        write(stdout, "Enter issue (Ctrl+D to end):")
        issue = read(stdin)
        if issue == none:
            return none
        write(stdout, "Enter repo path:")
        repo_path = read(stdin)
        if repo_path == none:
            repo_path = "."
        repo_path = repo_path.strip()
    
    grammar = read_text("prompts/cognos-flow-generator.md")
    dirs = shell(f"cd {repo_path} && find . -maxdepth 3 -type f -name '*.py' | head -40")
    top = shell(f"cd {repo_path} && ls -la | head -50")
    
    # --- Phase 1: Task analysis and decomposition ---
    write(stdout, "Phase 1: Analyzing task complexity...")
    
    decompose_prompt = f"""Analyze this task and decide the approach:

Task: {issue}

Repo structure:
{top}

Python files:
{dirs}

Respond in EXACTLY this format (no markdown):
COMPLEXITY: simple | multi-step
PLAN:
- step 1 description [depends: none]
- step 2 description [depends: none]
- step 3 description [depends: 1, 2]
...

Rules:
- simple = single logical change (one file, one concept)
- multi-step = requires investigation THEN separate changes, OR multiple files/concepts
- Keep steps to 2-4 max. Each step should produce a testable change.
- Each step description should be specific and actionable.
- Mark dependencies: [depends: none] for independent steps, [depends: 1, 2] for steps needing prior results.
- Investigation/read-only steps are usually independent of each other."""
    
    analysis_text = think(decompose_prompt, model="claude-sonnet-4-20250514")
    write(stdout, f"\n{analysis_text}\n")
    
    # Parse complexity
    is_multi = "COMPLEXITY: multi-step" in analysis_text
    
    # Parse steps with dependency info
    steps = []
    step_deps = []
    in_plan = false
    for line in analysis_text.split("\n"):
        if line.strip() == "PLAN:":
            in_plan = true
        elif in_plan and line.strip()[:2] == "- ":
            raw = line.strip()[2:]
            # Extract [depends: ...] tag
            deps = []
            if "[depends:" in raw:
                dep_start = raw.index("[depends:")
                dep_end = raw.index("]", dep_start)
                dep_text = raw[dep_start + 9:dep_end].strip()
                raw = raw[:dep_start].strip()
                if dep_text != "none":
                    for d in dep_text.split(","):
                        deps = deps + [int(d.strip())]
            steps = steps + [raw]
            step_deps = step_deps + [deps]
    
    if steps.length == 0:
        steps = ["Fix the issue as described"]
        step_deps = [[]]
        is_multi = false
    
    # --- Check for cached flows (scored) ---
    cached_flow = ""
    prior_results = recall_scored(f"cognos-flow: {issue[:200]}", limit=3)
    for item in prior_results:
        q = item["score"]
        sim = item["similarity"]
        if q >= 0.0 and sim > 0.5:
            write(stdout, f"Found cached flow (quality={q}, similarity={sim})")
            cached_flow = item["text"]
            break
    
    cache_hint = ""
    if cached_flow != "":
        cache_hint = f"\n\nPreviously successful flow for similar task — adapt, don't copy:\n{cached_flow}\n"
    
    if is_multi == false:
        # --- Simple mode: single flow (same as original meta-agent) ---
        write(stdout, f"\nSimple task — generating single flow...")
        
        gen_prompt = f"Write a Cognos flow called `solve` that fixes this bug.{cache_hint}\n\nCritical rules:\n- flow solve() -> String: (no parameters)\n- Do NOT use import — all tools are already available\n- think() WITHOUT tools= returns a String directly\n- ALWAYS pass model=\"claude-sonnet-4-20250514\" to think()\n- edit_file(path, old_text, new_text) — old_text must match EXACTLY. path is ABSOLUTE.\n- NEVER hardcode old_text — always read_lines first to get exact current content\n- For simple text replacements, prefer shell(\"sed -i 's/old/new/g' filepath\") — deterministic\n- When using think() to extract text, say 'Return ONLY the exact text' in the prompt\n- End with: return git_diff()\n- Repo path: {repo_path}\n\nPython files:\n{dirs}\n\nBug report:\n{issue}\n\nReturn ONLY the Cognos flow source code. No markdown fences."
        
        code = strip_fences(think(gen_prompt, system=grammar, model="claude-opus-4-6"))
        write_text("/tmp/cognos-generated-flow.cog", code)
        write(stdout, "\n--- Generated Flow ---")
        write(stdout, code)
        write(stdout, "--- End ---\n")
        
        outcome = execute_with_retry(code, "solve", grammar)
        if outcome["success"]:
            write(stdout, "\n--- PATCH ---")
            write(stdout, outcome["result"])
            write(stdout, "--- END PATCH ---")
            summary = issue[:200].replace("\n", " ")
            remember(f"cognos-flow: {summary}\n---\n{outcome['code']}", score=1.0)
        else:
            write(stdout, "Failed to solve.")
    else:
        # --- Multi-step mode with parallel generation for independent steps ---
        write(stdout, f"\nMulti-step task — {steps.length} phases:")
        idx = 0
        for s in steps:
            idx = idx + 1
            deps_str = "none"
            if step_deps[idx - 1].length > 0:
                dep_parts = []
                for d in step_deps[idx - 1]:
                    dep_parts = dep_parts + [str(d)]
                deps_str = dep_parts.join(", ")
            write(stdout, f"  {idx}. {s} [depends: {deps_str}]")
        
        all_context = ""
        step_results = {}
        completed = []
        
        # Execute steps respecting dependencies, parallelizing where possible
        remaining = []
        step_num = 0
        for s in steps:
            step_num = step_num + 1
            remaining = remaining + [step_num]
        
        loop:
            if remaining.length == 0:
                break
            
            # Find steps whose dependencies are all satisfied
            ready = []
            for sn in remaining:
                deps = step_deps[sn - 1]
                all_met = true
                for d in deps:
                    if d not in completed:
                        all_met = false
                        break
                if all_met:
                    ready = ready + [sn]
            
            if ready.length == 0:
                write(stdout, "ERROR: circular dependency detected")
                break
            
            # Generate flows for all ready steps in parallel (async)
            write(stdout, f"\n--- Generating {ready.length} flow(s) in parallel ---")
            futures = {}
            for sn in ready:
                step = steps[sn - 1]
                step_flow_name = f"step_{sn}"
                current_diff = shell(f"cd {repo_path} && git diff --stat")
                
                prev_changes = "No changes applied yet."
                if current_diff.strip() != "":
                    prev_changes = f"Previous steps already applied these changes:\n{current_diff}"
                
                prev_context = ""
                if all_context != "":
                    prev_context = f"Context from previous steps:\n{all_context}"
                
                step_prompt = f"""Write a Cognos flow called `{step_flow_name}` for this specific step of a larger task.{cache_hint}

Overall task: {issue}

This is step {sn} of {steps.length}.
Current step: {step}

{prev_changes}

{prev_context}

Critical rules:
- flow {step_flow_name}() -> String: (no parameters)
- Do NOT use import — all tools are already available
- think() WITHOUT tools= returns a String directly
- ALWAYS pass model="claude-sonnet-4-20250514" to think()
- edit_file(path, old_text, new_text) — old_text must match EXACTLY. path is ABSOLUTE.
- NEVER hardcode old_text — always read_lines first to get exact current content
- For simple text replacements, prefer shell("sed -i 's/old/new/g' filepath") — deterministic
- Return a brief summary of what was done (String)
- Repo path: {repo_path}

Python files:
{dirs}

Return ONLY the Cognos flow source code."""
                
                f = async think(step_prompt, system=grammar, model="claude-opus-4-6")
                futures = __map_set__(futures, str(sn), f)
            
            # Collect generated flows and execute sequentially (edits are ordered)
            for sn in ready:
                step = steps[sn - 1]
                step_flow_name = f"step_{sn}"
                sep = "=" * 50
                write(stdout, f"\n{sep}")
                write(stdout, f"Step {sn}/{steps.length}: {step}")
                write(stdout, sep)
                
                code = strip_fences(await(futures[str(sn)]))
                write_text(f"/tmp/cognos-step-{sn}.cog", code)
                write(stdout, f"\n--- Step {sn} Flow ---")
                write(stdout, code)
                write(stdout, "--- End ---\n")
                
                outcome = execute_with_retry(code, step_flow_name, grammar)
                
                if outcome["success"]:
                    write(stdout, f"Step {sn} completed: {outcome['result'][:200]}")
                    all_context = all_context + f"\nStep {sn} ({step}): {outcome['result'][:300]}"
                    step_results = __map_set__(step_results, str(sn), outcome["result"])
                    completed = completed + [sn]
                else:
                    write(stdout, f"Step {sn} FAILED — stopping pipeline.")
                    remaining = []
                    break
                
                # Remove from remaining
                new_remaining = []
                for r in remaining:
                    if r != sn:
                        new_remaining = new_remaining + [r]
                remaining = new_remaining
        
        # Final result
        diff = shell(f"cd {repo_path} && git diff")
        if diff.strip() != "":
            write(stdout, "\n--- PATCH ---")
            write(stdout, diff)
            write(stdout, "--- END PATCH ---")
            summary = issue[:200].replace("\n", " ")
            remember(f"cognos-multi-flow: {summary}\n---\nSteps: {steps.length}\n{all_context}", score=1.0)
            write(stdout, "Multi-step solution cached in memory.")
        else:
            write(stdout, "No changes produced.")

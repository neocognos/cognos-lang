{
  "stdin": [],
  "llm_responses": [
    "{\n  \"filename\": \"src/ast.rs\",\n  \"purpose\": \"Defines Abstract Syntax Tree (AST) structures for the Cognos programming language, including program structure, type definitions, control flow statements, and expressions\",\n  \"complexity\": 6,\n  \"issues\": [\n    \"Line 91: Comment mentions 'Ide' but actual field is 'Ident' - documentation mismatch\",\n    \"Line 1: #![allow(dead_code)] is overly broad and hides potentially unused code that should be cleaned up\",\n    \"Missing documentation for complex enum variants like TryCatch and FString\",\n    \"No validation or constraints on String fields (e.g., empty names, invalid identifiers)\",\n    \"TypeExpr::Struct uses Vec<(String, TypeExpr)> instead of a more structured approach\",\n    \"Missing Eq derive on some types that might benefit from it (TypeDef, FlowDef, etc.)\",\n    \"No lifetime parameters despite using owned strings everywhere, which may impact performance\",\n    \"BinOp enum is missing common operators like modulo (%), bitwise ops, string concatenation\"\n  ],\n  \"suggestions\": [\n    \"Add proper documentation with examples for all public types and complex enum variants\",\n    \"Replace #![allow(dead_code)] with more targeted allows or remove unused code\",\n    \"Add validation methods for identifier names and type consistency\",\n    \"Consider using interned strings or Cow<str> for frequently used string fields\",\n    \"Add Display implementations for better error messages and debugging\",\n    \"Consider adding source location information (line/column) to AST nodes for better error reporting\",\n    \"Add helper methods for common AST construction patterns\",\n    \"Implement From/Into traits for easier AST manipulation\",\n    \"Consider using a more structured approach for TypeExpr::Struct fields (e.g., a dedicated Field struct)\",\n    \"Add comprehensive unit tests for AST node construction and manipulation\"\n  ]\n}",
    "{\n  \"filename\": \"src/environment.rs\",\n  \"purpose\": \"Defines an abstraction layer for I/O operations with trait-based architecture, providing RealEnv for actual system operations and MockEnv for testing\",\n  \"complexity\": 5,\n  \"issues\": [\n    \"HTTP error handling uses unwrap_or_default() which silently swallows errors and returns empty strings\",\n    \"Shell command execution hardcoded to use 'sh -c' which may not work on all platforms (Windows)\",\n    \"MockEnv HTTP methods reuse the files HashMap, creating confusing coupling between file system and HTTP mocking\",\n    \"No timeout handling for HTTP requests which could hang indefinitely\",\n    \"LlmRequest has untyped tools field using serde_json::Value instead of proper type\",\n    \"Missing stderr capture in ShellResult struct\",\n    \"No validation of file paths in read_file/write_file methods\",\n    \"Tool calls in LlmResponse are untyped, making them difficult to work with safely\"\n  ],\n  \"suggestions\": [\n    \"Replace unwrap_or_default() in HTTP methods with proper error propagation\",\n    \"Add platform-specific shell detection or make shell command configurable\",\n    \"Separate HTTP mocking from file mocking in MockEnv for clarity\",\n    \"Add configurable timeouts for HTTP requests using reqwest client builder\",\n    \"Create strongly-typed structs for tools and tool_calls instead of using serde_json::Value\",\n    \"Add stderr field to ShellResult to capture command error output\",\n    \"Add path validation and normalization in file operations\",\n    \"Consider adding a Builder pattern for LlmRequest to ensure required fields are set\",\n    \"Add logging for HTTP operations similar to file operations\",\n    \"Consider making the trait async-compatible for better performance with I/O operations\"\n  ]\n}",
    "{\n  \"filename\": \"src/error.rs\",\n  \"purpose\": \"Defines a custom error system for the Cognos language with structured error types, formatting, and context-aware error messages for parsing, runtime, and type errors\",\n  \"complexity\": 4,\n  \"issues\": [\n    \"Large match expression in unexpected_token function (90+ lines) violates single responsibility principle\",\n    \"Hardcoded error messages mixed with logic makes internationalization difficult\",\n    \"No error code system for programmatic error handling\",\n    \"Missing source location information beyond line numbers (no column/span)\",\n    \"Token import suggests tight coupling with lexer module\",\n    \"No error chaining or cause tracking for nested errors\",\n    \"Constructor methods have inconsistent naming (type_error vs parse/runtime)\",\n    \"Display implementation doesn't show error kind, reducing debugging info\"\n  ],\n  \"suggestions\": [\n    \"Extract error message generation into separate module or trait\",\n    \"Add error codes enum for programmatic error handling\",\n    \"Include column numbers and source spans for better error reporting\",\n    \"Implement error chaining with source/cause tracking\",\n    \"Split unexpected_token function into smaller, categorized functions\",\n    \"Add severity levels (warning, error, fatal) to error system\",\n    \"Consider using thiserror crate for boilerplate reduction\",\n    \"Add structured error data for IDE integration and tooling\",\n    \"Implement consistent constructor naming pattern\",\n    \"Add helper methods for common error scenarios\"\n  ]\n}",
    "```json\n{\n  \"total_files\": 28,\n  \"total_lines\": 6472,\n  \"architecture\": \"Traditional language implementation stack with lexer->parser->AST->tree-walking interpreter pattern. Agentic programming language for deterministic control over AI-powered workflows with Python-like syntax and first-class LLM integration.\",\n  \"top_issues\": [\n    \"44 expect() calls in parser cause panics instead of graceful error handling\",\n    \"25+ unwrap() calls in interpreter create reliability issues with LLM/network failures\", \n    \"Platform compatibility issues - hardcoded 'sh -c' shell execution (Unix-only)\",\n    \"Environment trait design flaw - call_llm() marked as should not be called but implemented poorly\",\n    \"Type system incomplete - TypeDef exists but no runtime validation\",\n    \"No internationalization support - all error messages hardcoded in English\"\n  ],\n  \"overall_score\": 6\n}\n```"
  ],
  "shell": {
    "find src -name '*.rs' -type f | sort | head -3 | head -50": "src/ast.rs\nsrc/environment.rs\nsrc/error.rs"
  },
  "files": {
    "src/ast.rs": "#![allow(dead_code)]\n/// Abstract Syntax Tree for Cognos programs.\n\n#[derive(Debug, Clone)]\npub struct Program {\n    pub imports: Vec<String>,\n    pub types: Vec<TypeDef>,\n    pub flows: Vec<FlowDef>,\n}\n\n#[derive(Debug, Clone)]\npub struct TypeDef {\n    pub name: String,\n    pub fields: Vec<TypeField>,\n}\n\n#[derive(Debug, Clone)]\npub struct TypeField {\n    pub name: String,\n    pub ty: TypeExpr,\n}\n\n#[derive(Debug, Clone)]\npub struct FlowDef {\n    pub name: String,\n    pub description: Option<String>,\n    pub params: Vec<Param>,\n    pub return_type: Option<TypeExpr>,\n    pub body: Vec<Stmt>,\n}\n\n#[derive(Debug, Clone)]\npub struct Param {\n    pub name: String,\n    pub ty: TypeExpr,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum TypeExpr {\n    Named(String),                        // Text, Bool, Int\n    Generic(String, Vec<TypeExpr>),       // List[Text], Map[Text, Int]\n    Struct(Vec<(String, TypeExpr)>),      // { field: Type, ... }\n}\n\n#[derive(Debug, Clone)]\npub enum Stmt {\n    /// `name ",
    "src/environment.rs": "/// Environment trait \u2014 abstracts all I/O the interpreter needs.\n/// RealEnv talks to the OS. MockEnv returns canned responses.\n\nuse anyhow::Result;\n\npub trait Env {\n    fn read_stdin(&mut self) -> Result<String>;\n    fn write_stdout(&mut self, content: &str) -> Result<()>;\n    fn read_file(&self, path: &str) -> Result<String>;\n    fn write_file(&mut self, path: &str, content: &str) -> Result<()>;\n    fn exec_shell(&mut self, command: &str) -> Result<ShellResult>;\n    fn call_llm(&mut self, request: LlmRequest) -> Result<LlmResponse>;\n    fn http_get(&self, url: &str) -> Result<String>;\n    fn http_post(&self, url: &str, body: &str) -> Result<String>;\n\n    fn allow_shell(&self) -> bool;\n\n    /// Returns true for mock/test environments.\n    fn is_mock(&self) -> bool { false }\n\n    /// Collect stdout buffer (for testing). Returns None for real env.\n    fn captured_stdout(&self) -> Option<Vec<String>> { None }\n}\n\npub struct ShellResult {\n    pub stdout: String,\n    pub exit_code: i32,\n}\n\n",
    "src/error.rs": "#![allow(dead_code)]\n/// Cognos error system.\n/// Every error has a code, location, message, and optional hint.\n\nuse crate::token::Token;\nuse std::fmt;\n\n#[derive(Debug)]\npub struct CognosError {\n    pub kind: ErrorKind,\n    pub line: usize,\n    pub message: String,\n    pub hint: Option<String>,\n}\n\n#[derive(Debug)]\npub enum ErrorKind {\n    Parse,\n    Runtime,\n    Type,\n}\n\nimpl fmt::Display for CognosError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.line > 0 {\n            write!(f, \"line {}: {}\", self.line, self.message)?;\n        } else {\n            write!(f, \"{}\", self.message)?;\n        }\n        if let Some(hint) = &self.hint {\n            write!(f, \"\\n  hint: {}\", hint)?;\n        }\n        Ok(())\n    }\n}\n\nimpl std::error::Error for CognosError {}\n\nimpl CognosError {\n    pub fn parse(line: usize, message: impl Into<String>) -> Self {\n        Self { kind: ErrorKind::Parse, line, message: message.into(), hint: None }\n    }\n\n    pub fn parse_hint(li"
  }
}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cognos","text":"<p>Deterministic control over non-deterministic computation.</p> <p>Cognos is a programming language for agentic workflows. The LLM is a co-processor \u2014 you call it via <code>think()</code>, but everything else is deterministic, explicit, and testable.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Build\nPATH=\"$HOME/.cargo/bin:$PATH\" cargo build\n\n# Run a program\ncognos run examples/hello.cog\n\n# Run with shell access\ncognos run --allow-shell examples/shell-agent.cog\n\n# Test with mock environment (no LLM, no network)\ncognos test examples/chat.cog --env examples/mocks/chat-test.json\n\n# Interactive REPL\ncognos repl\n</code></pre>"},{"location":"#hello-world","title":"Hello World","text":"<pre><code>flow main():\n    write(stdout, \"Hello, World!\")\n</code></pre>"},{"location":"#a-chat-agent-12-lines","title":"A Chat Agent (12 lines)","text":"<pre><code>flow main():\n    history = []\n    write(stdout, \"Chat ready. Type 'quit' to exit.\")\n    loop:\n        input = read(stdin)\n        if input == \"quit\":\n            break\n        history = history + [f\"User: {input}\"]\n        context = history.join(\"\\n\")\n        response = think(context, model=\"qwen2.5:7b\", system=\"You are a helpful assistant.\")\n        history = history + [f\"Assistant: {response}\"]\n        write(stdout, response)\n</code></pre>"},{"location":"#a-shell-agent-with-tools","title":"A Shell Agent with Tools","text":"<pre><code>import \"lib/exec.cog\"\n\nflow shell(command: String) -&gt; String:\n    \"Execute a sandboxed shell command\"\n    return __exec_shell__(command)\n\nflow main():\n    write(stdout, \"Agent ready. Type 'quit' to exit.\")\n    loop:\n        input = read(stdin)\n        if input == \"quit\":\n            break\n        response = think(input, model=\"claude-sonnet-4-20250514\",\n            system=\"You are a helpful assistant with shell access.\",\n            tools=[\"shell\"])\n        if response[\"has_tool_calls\"]:\n            response = exec(response, tools=[\"shell\"])\n        write(stdout, response)\n</code></pre>"},{"location":"#features","title":"Features","text":"Feature Example Types <code>String</code>, <code>Int</code>, <code>Float</code>, <code>Bool</code>, <code>List</code>, <code>Map</code>, <code>Handle</code>, <code>Module</code> Custom types <code>type Review: score: Int, summary: String</code> LLM calls <code>think(input, model=\"claude-sonnet-4-20250514\", system=\"Be concise.\")</code> Structured output <code>think(input, format=\"Review\")</code> \u2014 LLM returns typed Map Tools <code>think(input, tools=[\"search\", \"shell\"])</code> \u2014 flows as LLM tools Dynamic dispatch <code>invoke(\"flow_name\", {\"arg\": value})</code> \u2014 call flows by string name Stdlib <code>import \"lib/exec.cog\"</code> \u2014 tool execution, agent loops in <code>.cog</code> F-strings <code>f\"Hello {name}, you have {count} items\"</code> I/O handles <code>read(stdin)</code>, <code>write(stdout, ...)</code>, <code>read(file(\"path\"))</code> Shell <code>__exec_shell__(\"ls\")</code> (requires <code>--allow-shell</code>) Imports <code>import \"lib/utils.cog\"</code> Error handling <code>try: ... catch err: ...</code> Persistence <code>save(\"state.json\", data)</code>, <code>load(\"state.json\")</code> Native modules <code>math.sin(x)</code>, <code>math.pi</code>, <code>http.get(url)</code> Mock testing <code>cognos test agent.cog --env mock.json</code> Tracing <code>cognos run --trace trace.jsonl --trace-level full agent.cog</code> Control flow <code>if</code>/<code>elif</code>/<code>else</code>, <code>loop</code>, <code>for</code>, <code>break</code>, <code>continue</code> REPL <code>cognos repl</code> \u2014 interactive experimentation"},{"location":"#design-principles","title":"Design Principles","text":"<ul> <li>Start with nothing, add what you need. No accidental complexity.</li> <li>Channel agnostic. <code>read(stdin)</code> / <code>write(stdout, ...)</code> \u2014 same code works in CLI, TUI, API, Slack.</li> <li>The LLM is a co-processor. <code>think()</code> is the only non-deterministic primitive.</li> <li>Environment agnostic. Same <code>.cog</code> runs in production or against a mock \u2014 no code changes.</li> <li>Builtins are atomic. Rust builtins perform one I/O operation. Orchestration belongs in <code>.cog</code> flows.</li> <li>Sandboxed by design. Shell disabled by default. <code>--allow-shell</code> for explicit opt-in.</li> <li>Platform portable. <code>.cog</code> files run anywhere the interpreter compiles.</li> </ul>"},{"location":"#cli","title":"CLI","text":"<pre><code>cognos run [flags] &lt;file.cog&gt;       # run a program\ncognos test &lt;file.cog&gt; --env &lt;mock&gt; # test with mock environment\ncognos parse &lt;file.cog&gt;             # pretty-print parsed AST\ncognos tokens &lt;file.cog&gt;            # show raw tokens\ncognos repl                         # interactive REPL\n</code></pre>"},{"location":"#flags","title":"Flags","text":"Flag Description <code>--allow-shell</code> Enable shell execution <code>--trace &lt;path&gt;</code> Write JSONL trace events to file <code>--trace-level metrics\\|full</code> Trace detail level (default: metrics) <code>--env &lt;mock.json&gt;</code> Mock environment file (for <code>cognos test</code>) <code>--session &lt;path&gt;</code> Auto-save/load variables between runs <code>-v</code> / <code>-vv</code> / <code>-vvv</code> Log verbosity (info/debug/trace)"},{"location":"#llm-providers","title":"LLM Providers","text":"Model prefix Provider Auth <code>claude-*</code> Claude CLI \u2192 Anthropic API fallback Max subscription or <code>ANTHROPIC_API_KEY</code> anything else Ollama (local) None needed"},{"location":"#examples","title":"Examples","text":"<pre><code>cognos run examples/hello.cog                        # hello world\ncognos run examples/chat.cog                         # LLM chat (needs Ollama)\ncognos run --allow-shell examples/shell-agent.cog    # shell agent (needs Claude)\ncognos run examples/import-test.cog                  # multi-file import\ncognos run examples/try-catch.cog                    # error handling\ncognos run examples/session-save.cog                 # save/load persistence\ncognos test examples/chat.cog --env examples/mocks/chat-test.json  # mock test\n</code></pre>"},{"location":"#docs","title":"Docs","text":"<ul> <li>Language Specification</li> <li>Tracing &amp; Diagnostics</li> <li>Environments &amp; Testing</li> <li>Import System</li> <li>Error Handling &amp; Persistence</li> <li>Memory Design</li> <li>Compilation Strategy</li> <li>Examples</li> </ul>"},{"location":"#testing","title":"Testing","text":"<pre><code>PATH=\"$HOME/.cargo/bin:$PATH\" cargo test\n</code></pre> <p>139 tests: lexer, parser, interpreter, integration, type errors, mock environments.</p>"},{"location":"docs/comparison-pydantic/","title":"Cognos vs PydanticAI \u2014 Side-by-Side Comparison","text":"<p>The same agent: analyze source files, validate structured output, generate project summary.</p>"},{"location":"docs/comparison-pydantic/#cognos-68-lines","title":"Cognos (68 lines)","text":"<pre><code>import \"lib/validated_think.cog\"\n\ntype FileAnalysis:\n    filename: String\n    purpose: String\n    complexity: Int\n    issues: List\n    suggestions: List\n\ntype ProjectSummary:\n    total_files: Int\n    total_lines: Int\n    architecture: String\n    top_issues: List\n    overall_score: Int\n\nflow shell(command: String) -&gt; String:\n    \"Execute a sandboxed shell command.\"\n    return __exec_shell__(f\"{command} | head -50\")\n\nflow read_file(path: String) -&gt; String:\n    \"Read the contents of a file\"\n    return read(file(path))\n\nflow main():\n    files_raw = shell(\"find src -name '*.rs' -type f | sort | head -3\")\n    files = files_raw.split(\"\\n\")\n\n    analyses = []\n    for filepath in files:\n        if filepath == \"\":\n            continue\n        try:\n            content = read_file(filepath)\n            preview = content[0:2000]\n            analysis = validated_think(\n                f\"File: {filepath}\\n\\n{preview}\",\n                \"FileAnalysis\",\n                \"claude-sonnet-4-20250514\",\n                \"Analyze this source file. Rate complexity 1-10.\",\n                \"qwen2.5:1.5b\"\n            )\n            analyses = analyses + [analysis]\n        catch err:\n            write(stdout, f\"Error: {err}\")\n\n    summary = validated_think(\n        f\"Project with {files.length} files:\\n{analyses}\",\n        \"ProjectSummary\",\n        \"claude-sonnet-4-20250514\",\n        \"Summarize this project analysis. Score 1-10.\",\n        \"qwen2.5:1.5b\"\n    )\n\n    save(\"analysis-report.json\", summary)\n</code></pre> <p>Test: <pre><code>cognos test code-analyzer.cog --env mocks/code-analyzer-sonnet.json\n</code></pre></p>"},{"location":"docs/comparison-pydantic/#pydanticai-145-lines","title":"PydanticAI (145 lines)","text":"<pre><code>import asyncio\nimport json\nimport subprocess\nfrom pathlib import Path\nfrom typing import List\n\nfrom pydantic import BaseModel, Field\nfrom pydantic_ai import Agent, RunContext\n\n# --- Types (same as Cognos type definitions) ---\n\nclass FileAnalysis(BaseModel):\n    filename: str\n    purpose: str\n    complexity: int = Field(ge=1, le=10)\n    issues: List[str]\n    suggestions: List[str]\n\nclass ProjectSummary(BaseModel):\n    total_files: int\n    total_lines: int\n    architecture: str\n    top_issues: List[str]\n    overall_score: int = Field(ge=1, le=10)\n\n# --- Agent setup ---\n\nfile_analyzer = Agent(\n    \"anthropic:claude-sonnet-4-20250514\",\n    result_type=FileAnalysis,\n    system_prompt=\"Analyze this source file. Rate complexity 1-10.\",\n    retries=3,\n)\n\nproject_summarizer = Agent(\n    \"anthropic:claude-sonnet-4-20250514\",\n    result_type=ProjectSummary,\n    system_prompt=\"Summarize this project analysis. Score 1-10.\",\n    retries=3,\n)\n\n# --- Tools (registered as decorators) ---\n\n@file_analyzer.tool\nasync def shell(ctx: RunContext, command: str) -&gt; str:\n    \"\"\"Execute a sandboxed shell command.\"\"\"\n    result = subprocess.run(\n        f\"{command} | head -50\",\n        shell=True,\n        capture_output=True,\n        text=True,\n        timeout=30,\n    )\n    return result.stdout\n\n@file_analyzer.tool\nasync def read_file(ctx: RunContext, path: str) -&gt; str:\n    \"\"\"Read the contents of a file.\"\"\"\n    return Path(path).read_text()\n\n# --- Main flow ---\n\nasync def main():\n    # Step 1: Discover files\n    result = subprocess.run(\n        \"find src -name '*.rs' -type f | sort | head -3\",\n        shell=True,\n        capture_output=True,\n        text=True,\n    )\n    files = [f for f in result.stdout.strip().split(\"\\n\") if f]\n\n    # Step 2: Analyze each file\n    analyses = []\n    for filepath in files:\n        try:\n            content = Path(filepath).read_text()\n            preview = content[:2000]\n            result = await file_analyzer.run(\n                f\"File: {filepath}\\n\\n{preview}\"\n            )\n            analyses.append(result.data)\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n    # Step 3: Generate project summary\n    analyses_text = \"\\n\".join(\n        f\"- {a.filename}: complexity={a.complexity}, issues={a.issues}\"\n        for a in analyses\n    )\n    result = await project_summarizer.run(\n        f\"Project with {len(files)} files:\\n{analyses_text}\"\n    )\n    summary = result.data\n\n    # Save results\n    Path(\"analysis-report.json\").write_text(\n        json.dumps(summary.model_dump(), indent=2)\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Test: <pre><code># Requires: pytest, pytest-asyncio, custom mock setup\nimport pytest\nfrom unittest.mock import AsyncMock, patch, MagicMock\n\n@pytest.mark.asyncio\nasync def test_code_analyzer():\n    mock_response = MagicMock()\n    mock_response.data = FileAnalysis(\n        filename=\"main.rs\",\n        purpose=\"Entry point\",\n        complexity=3,\n        issues=[\"No error handling\"],\n        suggestions=[\"Add Result types\"],\n    )\n\n    with patch.object(file_analyzer, 'run', new_callable=AsyncMock) as mock_run:\n        mock_run.return_value = mock_response\n        with patch('subprocess.run') as mock_shell:\n            mock_shell.return_value = MagicMock(stdout=\"src/main.rs\\n\")\n            with patch('pathlib.Path.read_text', return_value=\"fn main() {}\"):\n                await main()\n\n    # Assert... what exactly? stdout? file written?\n    # Need more mocking for Path.write_text...\n</code></pre></p>"},{"location":"docs/comparison-pydantic/#comparison","title":"Comparison","text":"Aspect Cognos PydanticAI Lines of code 68 145 Dependencies 0 (just <code>cognos</code> binary) pydantic, pydantic-ai, anthropic SDK, asyncio Type definitions 8 lines 13 lines (+ imports) Tool definitions Flows \u2014 same as any other function Decorators on agent instances Agent creation None \u2014 <code>think()</code> is the agent Explicit <code>Agent()</code> objects per task Structured output <code>format=\"FileAnalysis\"</code> on any think() <code>result_type=</code> locked to agent instance Retry/validation <code>validated_think()</code> \u2014 a .cog flow you can read and modify <code>retries=3</code> \u2014 black box, can't customize Error handling <code>try/catch</code> <code>try/except</code> (same) Testing <code>cognos test --env mock.json</code> (one command, zero code) 20+ lines of mock setup per test Mock creation <code>cognos trace-to-mock trace.jsonl</code> (automatic) Manual mock construction Shell access Sandboxed by default, <code>--allow-shell</code> flag Unrestricted <code>subprocess.run</code> Multi-model Change <code>model=</code> on any think() call Create separate Agent per model Async Sync by default (LLM calls are blocking anyway) Forced async everywhere Runtime Single 5MB binary Python 3.11+, pip, venv, 50+ transitive deps Tracing <code>--trace file.jsonl</code> built-in OpenTelemetry setup required"},{"location":"docs/comparison-pydantic/#key-differences","title":"Key Differences","text":"<p>1. Agent-per-task vs think-per-call PydanticAI creates an <code>Agent</code> object per task (file_analyzer, project_summarizer). Cognos just calls <code>think()</code> with different parameters. Less ceremony, more flexible.</p> <p>2. Testing is night and day Cognos: record a trace, derive a mock, replay it. One command. Zero test code. PydanticAI: AsyncMock, patch decorators, MagicMock, nested context managers. Fragile.</p> <p>3. Forced async PydanticAI forces <code>async/await</code> everywhere because it uses asyncio. But LLM calls take 2-30 seconds \u2014 the async overhead buys nothing for sequential agents. Cognos is sync by default, async when you choose it.</p> <p>4. Tool registration PydanticAI tools are decorators tied to specific agent instances. If two agents need the same tool, you register it twice. Cognos tools are just flows \u2014 any think() call can use any flow as a tool.</p> <p>5. Observability Cognos traces every LLM call, tool call, shell exec, and I/O operation automatically. PydanticAI requires instrumenting with Logfire or OpenTelemetry.</p>"},{"location":"docs/design-principles/","title":"Cognos Design Principles","text":""},{"location":"docs/design-principles/#the-principles","title":"The Principles","text":""},{"location":"docs/design-principles/#p1-start-with-nothing-add-what-you-need","title":"P1: Start with nothing, add what you need","text":"<p>No accidental complexity. Every feature must earn its place.</p>"},{"location":"docs/design-principles/#p2-channel-agnostic","title":"P2: Channel agnostic","text":"<p>Flows declare what input they need, not where it comes from. <code>read(stdin)</code> works in CLI, TUI, API, Slack \u2014 the runtime maps the channel.</p>"},{"location":"docs/design-principles/#p3-the-llm-is-a-co-processor","title":"P3: The LLM is a co-processor","text":"<p><code>think()</code> is the only non-deterministic primitive. Everything else is explicit, typed, and testable.</p>"},{"location":"docs/design-principles/#p4-environment-agnostic","title":"P4: Environment agnostic","text":"<p>Same <code>.cog</code> runs in production or against a mock. No code changes. The <code>Env</code> trait abstracts all I/O.</p>"},{"location":"docs/design-principles/#p5-sandboxed-by-design","title":"P5: Sandboxed by design","text":"<p>Only builtins can interact with the outside world. Shell is disabled by default (<code>--allow-shell</code>). Sandbox policy lives in <code>.cog</code> files, not the runtime.</p>"},{"location":"docs/design-principles/#p6-builtins-are-atomic","title":"P6: Builtins are atomic","text":"<p>Rust builtins perform exactly one I/O operation. No loops, no branching, no flow calls. Orchestration belongs in <code>.cog</code> flows.</p>"},{"location":"docs/design-principles/#p7-platform-portable","title":"P7: Platform portable","text":"<p><code>.cog</code> files run anywhere the interpreter compiles. No OS-specific constructs in the language.</p>"},{"location":"docs/design-principles/#p8-behaviors-in-language-not-runtime","title":"P8: Behaviors in language, not runtime","text":"<p>Agent behaviors (retry logic, tool loops, memory strategy) are defined in <code>.cog</code> files, not hardcoded in Rust. The runtime provides primitives; the programmer defines policy.</p>"},{"location":"docs/design-principles/#p9-one-feature-multiple-use-cases","title":"P9: One feature, multiple use cases","text":"<p>Prefer a single general mechanism over multiple specialized ones. Example: <code>type</code> covers both structured output and JSON format validation.</p>"},{"location":"docs/design-principles/#p10-testability-first","title":"P10: Testability first","text":"<p>Every agent must be testable without LLM calls, network, or filesystem. Mock environments are a first-class concept, not an afterthought.</p>"},{"location":"docs/design-principles/#p11-lean-core-runtime","title":"P11: Lean core runtime","text":"<p>Cognos is a domain language for agents, not a general-purpose language. Resist adding features that exist in Python/JS/Go. If you need a hash map library, data science toolkit, or web framework \u2014 use a real language. Cognos handles the agent loop: think, act, observe, remember. Everything else is out of scope.</p>"},{"location":"docs/design-principles/#architecture-review","title":"Architecture Review","text":""},{"location":"docs/design-principles/#rust-builtins-audit-p6-builtins-are-atomic","title":"Rust Builtins Audit (P6: Builtins are atomic)","text":"Builtin Atomic? Verdict <code>think()</code> \u26a0\ufe0f VIOLATION See below <code>invoke(name, args)</code> \u2705 One flow call, returns result <code>read(handle)</code> \u2705 One read operation <code>write(handle, content)</code> \u2705 One write operation <code>file(path)</code> \u2705 Creates a handle value (pure) <code>__exec_shell__(cmd)</code> \u2705 One shell command <code>save(path, value)</code> \u2705 One file write <code>load(path)</code> \u2705 One file read <code>log(msg)</code> / <code>print(msg)</code> \u2705 One stderr write <code>emit(value)</code> \u2705 Alias for write(stdout, ...)"},{"location":"docs/design-principles/#p6-violations","title":"P6 Violations","text":""},{"location":"docs/design-principles/#think-format-validation-schema-injection","title":"<code>think()</code> \u2014 format validation + schema injection","text":"<p><code>think()</code> currently does three things: 1. Call the LLM \u2014 atomic \u2705 2. Inject type schema into system prompt (<code>format=</code>) \u2014 preparation, not I/O \u26a0\ufe0f 3. Parse + validate JSON response (<code>format=</code>) \u2014 post-processing \u26a0\ufe0f</p> <p>Steps 2 and 3 are orchestration logic embedded in the builtin. They should be in <code>.cog</code>:</p> <p>Option A: Keep as-is (pragmatic) - Schema injection is prompt construction, not a separate I/O operation - Validation is a check on the return value, not a loop or branch - Moving it to <code>.cog</code> would require exposing <code>type_schema()</code> as a builtin</p> <p>Option B: Split (pure) - <code>think()</code> only calls LLM, returns raw string - <code>type_schema(name)</code> builtin returns the JSON schema string - <code>validate(value, type_name)</code> builtin checks a value against a type - <code>formatted_think()</code> in <code>.cog</code> stdlib composes them</p> <p>Recommendation: Option A for now. The format/validation logic doesn't loop, doesn't call flows, and doesn't do I/O. It's data transformation on the builtin's return value. A strict reading of P6 says split it, but the pragmatic cost is high (3 new builtins, user complexity).</p> <p>Decision needed from Reza.</p>"},{"location":"docs/design-principles/#think-tools-kwarg","title":"<code>think()</code> \u2014 tools= kwarg","text":"<p><code>think()</code> builds tool JSON schemas from flow signatures when <code>tools=</code> is passed. This is: - Reading flow definitions (data access, not I/O) - Building JSON (data transformation) - Passing to LLM call (part of the one I/O operation)</p> <p>Verdict: Acceptable. It's preparing the LLM request, not orchestrating.</p>"},{"location":"docs/design-principles/#channel-agnosticism-audit-p2","title":"Channel Agnosticism Audit (P2)","text":"Item Status <code>read(stdin)</code> / <code>write(stdout, ...)</code> \u2705 Handle-based, channel-mapped Flow params bound from stdin in CLI \u2705 <code>print(\"&gt; \")</code> for prompts \u26a0\ufe0f Leaks presentation into logic <code>emit()</code> \u2705 Sugar for <code>write(stdout, ...)</code> <p>Minor violation: When <code>main()</code> has params, the interpreter prints <code>&gt;</code> before reading each one. This presentation detail should be the runtime's concern, not injected by the interpreter. Low priority.</p>"},{"location":"docs/design-principles/#environment-agnosticism-audit-p4","title":"Environment Agnosticism Audit (P4)","text":"I/O Operation Routes through Env? stdin read \u2705 <code>env.read_stdin()</code> stdout write \u2705 <code>env.write_stdout()</code> file read \u2705 <code>env.read_file()</code> file write \u2705 <code>env.write_file()</code> shell exec \u2705 <code>env.exec_shell()</code> LLM calls \u2705 <code>env.call_llm()</code> (mock) / direct (real) HTTP \u2705 <code>env.http_get()</code> / <code>env.http_post()</code> <code>save()</code> \u2705 <code>env.write_file()</code> <code>load()</code> \u2705 <code>env.read_file()</code> <p>Violations: <code>save()</code> and <code>load()</code> bypass the Env trait. In MockEnv, <code>save()</code> writes to real filesystem and <code>load()</code> reads from real filesystem. They should go through <code>env.write_file()</code> and <code>env.read_file()</code>.</p>"},{"location":"docs/design-principles/#sandbox-audit-p5","title":"Sandbox Audit (P5)","text":"Item Status Shell disabled by default \u2705 <code>--allow-shell</code> required Shell policy in <code>.cog</code> \u2705 <code>shell()</code> is a user flow File access unrestricted \u26a0\ufe0f No path restrictions HTTP unrestricted \u26a0\ufe0f Any URL accessible <code>invoke()</code> unrestricted \u26a0\ufe0f Can call any flow by name <p>Gaps: No working directory sandbox or path restrictions yet. On the roadmap.</p>"},{"location":"docs/design-principles/#testability-audit-p10","title":"Testability Audit (P10)","text":"Item Status Mock environment \u2705 <code>cognos test --env mock.json</code> All I/O through Env \u26a0\ufe0f <code>save()</code>/<code>load()</code> bypass Deterministic mock replay \u2705 Traces \u2192 mocks \u2192 replay trace-to-mock CLI \u2705 <code>cognos trace-to-mock</code> CI-friendly \u2705 Zero external deps for mock tests"},{"location":"docs/design-principles/#behaviors-in-language-audit-p8","title":"Behaviors in Language Audit (P8)","text":"Behavior In <code>.cog</code>? Tool execution loop \u2705 <code>lib/exec.cog</code> Auto tool loop \u2705 <code>lib/agent.cog</code> Retry with validation \u2705 <code>lib/validated_think.cog</code> Shell sandboxing \u2705 User-defined <code>shell()</code> flow Memory strategy \u2705 Planned for <code>.cog</code> Format validation \u26a0\ufe0f In Rust (see think() discussion above)"},{"location":"docs/design-principles/#action-items","title":"Action Items","text":""},{"location":"docs/design-principles/#fixed","title":"Fixed","text":"<ol> <li>~~<code>save()</code>/<code>load()</code> must route through Env~~ \u2014 \u2705 Now routes through <code>env.write_file()</code> / <code>env.read_file()</code></li> <li>~~Prompt <code>&gt;</code> in param binding~~ \u2014 \u2705 Removed presentation from interpreter</li> </ol>"},{"location":"docs/design-principles/#decided","title":"Decided","text":"<ol> <li><code>think()</code> format validation stays in Rust \u2014 it's the marshalling layer (type boundary between LLM world and Cognos world), not orchestration. Schema injection, JSON parsing, and type validation are all part of the single atomic operation: \"call LLM, return typed value.\" This extends naturally to multimodal: <code>think(audio_handle, format=\"Transcript\")</code> \u2014 same boundary, different media.</li> </ol>"},{"location":"docs/design-principles/#deferred-on-roadmap","title":"Deferred (on roadmap)","text":"<ol> <li>Path restrictions for file access (P5)</li> <li>HTTP URL restrictions (P5)</li> </ol>"},{"location":"docs/environments/","title":"Environments","text":"<p>Cognos agents are environment-agnostic. The same <code>.cog</code> file runs in production or against a mock \u2014 no code changes.</p>"},{"location":"docs/environments/#how-it-works","title":"How It Works","text":"<p>Every I/O operation goes through an <code>Env</code> trait:</p> Operation Method <code>read(stdin)</code> <code>env.read_stdin()</code> <code>write(stdout, ...)</code> <code>env.write_stdout()</code> <code>read(file(\"...\"))</code> <code>env.read_file()</code> <code>write(file(\"...\"), ...)</code> <code>env.write_file()</code> <code>__exec_shell__(...)</code> <code>env.exec_shell()</code> <code>think(...)</code> <code>env.call_llm()</code> <code>http.get(...)</code> <code>env.http_get()</code> <code>http.post(...)</code> <code>env.http_post()</code>"},{"location":"docs/environments/#real-environment-default","title":"Real Environment (default)","text":"<pre><code>cognos run agent.cog\n</code></pre> <p>Uses real stdin/stdout, filesystem, shell, and LLM providers (Ollama/Claude).</p>"},{"location":"docs/environments/#mock-environment","title":"Mock Environment","text":"<pre><code>cognos test agent.cog --env mock.json\n</code></pre> <p>All I/O is mocked. No network, no filesystem, no LLM calls. Instant, deterministic, free.</p>"},{"location":"docs/environments/#mock-file-format","title":"Mock File Format","text":"<pre><code>{\n  \"stdin\": [\"user input line 1\", \"user input line 2\", \"quit\"],\n  \"llm_responses\": [\n    \"Simple text response\",\n    {\n      \"content\": \"\",\n      \"tool_calls\": [{\"name\": \"shell\", \"arguments\": {\"command\": \"date\"}}]\n    },\n    \"Follow-up response after tool call\"\n  ],\n  \"shell\": {\n    \"date\": \"Thu Feb 12 00:34:00 CET 2026\",\n    \"ls -la\": \"total 42\\n-rw-r--r-- 1 user user 100 file.txt\"\n  },\n  \"files\": {\n    \"config.txt\": \"key=value\",\n    \"data.json\": \"{\\\"items\\\": [1, 2, 3]}\"\n  },\n  \"allow_shell\": true\n}\n</code></pre>"},{"location":"docs/environments/#fields","title":"Fields","text":"Field Description <code>stdin</code> Array of strings \u2014 each <code>read(stdin)</code> consumes one <code>llm_responses</code> Array \u2014 each <code>think()</code> consumes one. String or object with <code>content</code> + <code>tool_calls</code> <code>shell</code> Map of command \u2192 output. Exact match or base command (before <code>\\|</code>) <code>files</code> Map of path \u2192 content for <code>read(file(...))</code> <code>allow_shell</code> Whether shell execution is allowed (default: true)"},{"location":"docs/environments/#output","title":"Output","text":"<pre><code>\u2500\u2500\u2500 Mock Output (2 lines) \u2500\u2500\u2500\n  Chat ready. Type 'quit' to exit.\n  Hi there! How can I help you today?\n\u2500\u2500\u2500 Pass \u2713 \u2500\u2500\u2500\n</code></pre> <p>All <code>write(stdout, ...)</code> calls are captured and printed at the end.</p>"},{"location":"docs/environments/#use-cases","title":"Use Cases","text":""},{"location":"docs/environments/#unit-testing-agents","title":"Unit Testing Agents","text":"<p>Test an agent's logic without LLM costs:</p> <pre><code>{\n  \"stdin\": [\"summarize my code\", \"quit\"],\n  \"llm_responses\": [\n    {\"content\": \"\", \"tool_calls\": [{\"name\": \"shell\", \"arguments\": {\"command\": \"cat main.py\"}}]},\n    \"Your code implements a REST API with 3 endpoints.\"\n  ],\n  \"shell\": {\n    \"cat main.py\": \"from flask import Flask\\napp = Flask(__name__)\\n@app.route('/')\\ndef home(): return 'hello'\"\n  }\n}\n</code></pre>"},{"location":"docs/environments/#cicd","title":"CI/CD","text":"<pre><code># GitHub Actions\n- name: Test agents\n  run: |\n    cognos test examples/chat.cog --env tests/chat-mock.json\n    cognos test examples/shell-agent.cog --env tests/shell-mock.json\n</code></pre>"},{"location":"docs/environments/#regression-testing","title":"Regression Testing","text":"<p>Record a trace (<code>--trace-level full</code>), then convert it to a mock file to replay:</p> <pre><code># Record\ncognos run agent.cog --trace trace.jsonl --trace-level full\n\n# Convert trace to mock (coming soon)\ncognos trace-to-mock trace.jsonl &gt; mock.json\n\n# Replay\ncognos test agent.cog --env mock.json\n</code></pre>"},{"location":"docs/environments/#design-principle","title":"Design Principle","text":"<p>The <code>.cog</code> file never knows which environment it's running in. It just calls <code>read()</code>, <code>write()</code>, <code>think()</code>, <code>shell()</code>. The environment is set by the runner, not the code. Agents are pure logic.</p>"},{"location":"docs/error-handling/","title":"Error Handling","text":""},{"location":"docs/error-handling/#trycatch","title":"Try/Catch","text":"<p>Catch errors gracefully instead of crashing.</p> <pre><code>try:\n    content = read(file(\"data.txt\"))\ncatch err:\n    content = \"default value\"\n    write(stdout, f\"Warning: {err}\")\n</code></pre>"},{"location":"docs/error-handling/#syntax","title":"Syntax","text":"<pre><code>try:\n    &lt;body&gt;\ncatch [error_var]:\n    &lt;handler&gt;\n</code></pre> <ul> <li><code>error_var</code> is optional \u2014 if provided, the error message is bound to it as a String</li> <li>The catch block runs only if the try block errors</li> <li>Variables set in the try block are visible after it (if no error)</li> </ul>"},{"location":"docs/error-handling/#examples","title":"Examples","text":"<p>Graceful file loading: <pre><code>try:\n    config = load(\"config.json\")\ncatch:\n    config = {\"port\": 8080, \"debug\": false}\n</code></pre></p> <p>LLM fallback: <pre><code>try:\n    response = think(prompt, model=\"claude-sonnet-4-20250514\")\ncatch err:\n    write(stdout, f\"Claude failed: {err}, trying local model...\")\n    response = think(prompt, model=\"qwen2.5:7b\")\n</code></pre></p> <p>Session persistence pattern: <pre><code>flow main():\n    # Load previous session or start fresh\n    try:\n        history = load(\"session.json\")\n    catch:\n        history = []\n\n    # ... agent loop ...\n\n    # Save on exit\n    save(\"session.json\", history)\n</code></pre></p>"},{"location":"docs/error-handling/#save-load","title":"Save / Load","text":"<p>Persist any Cognos value as JSON.</p> <pre><code>save(path, value)    # writes value as pretty JSON\nvalue = load(path)   # reads JSON back to Cognos value\n</code></pre>"},{"location":"docs/error-handling/#type-mapping","title":"Type Mapping","text":"Cognos JSON String string Int number Float number Bool boolean None null List array Map object"},{"location":"docs/error-handling/#example","title":"Example","text":"<pre><code>data = {\"name\": \"agent\", \"turns\": 42, \"history\": [\"hello\", \"world\"]}\nsave(\"state.json\", data)\n\n# Later...\nloaded = load(\"state.json\")\nwrite(stdout, loaded[\"name\"])     # \"agent\"\nwrite(stdout, loaded[\"history\"])  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"docs/import/","title":"Import","text":"<p>Import flows and types from other <code>.cog</code> files.</p>"},{"location":"docs/import/#syntax","title":"Syntax","text":"<pre><code>import \"path/to/module.cog\"\n</code></pre> <p>Imports must appear at the top of the file, before any type or flow definitions.</p>"},{"location":"docs/import/#how-it-works","title":"How It Works","text":"<ul> <li>The imported file is parsed and its flows and types are registered</li> <li>Imports resolve relative to the importing file's directory</li> <li>Imported files can themselves import other files (recursive)</li> <li>If two files define the same flow name, the last import wins</li> </ul>"},{"location":"docs/import/#example","title":"Example","text":"<p>lib/greet.cog: <pre><code>flow greet(name: String) -&gt; String:\n    return f\"Hello, {name}!\"\n</code></pre></p> <p>main.cog: <pre><code>import \"lib/greet.cog\"\n\nflow main():\n    msg = greet(\"World\")\n    write(stdout, msg)\n</code></pre></p> <pre><code>$ cognos run main.cog\nHello, World!\n</code></pre>"},{"location":"docs/import/#building-libraries","title":"Building Libraries","text":"<p>Organize reusable flows into library files:</p> <pre><code>my-agent/\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 shell.cog      # shell(), read_file(), write_file()\n\u2502   \u251c\u2500\u2500 memory.cog     # remember(), recall()\n\u2502   \u2514\u2500\u2500 http.cog       # fetch(), post()\n\u251c\u2500\u2500 main.cog\n</code></pre> <pre><code>import \"lib/shell.cog\"\nimport \"lib/memory.cog\"\n\nflow main():\n    result = shell(\"ls -la\")\n    write(stdout, result)\n</code></pre>"},{"location":"docs/memory/","title":"Memory in Cognos","text":""},{"location":"docs/memory/#philosophy","title":"Philosophy","text":"<p>Memory strategy is logic \u2014 it belongs in <code>.cog</code> files, not hardcoded in the runtime. The runtime provides primitives (<code>remember()</code>, <code>recall()</code>); your code decides what to store and when to retrieve.</p>"},{"location":"docs/memory/#current-list-based-history","title":"Current: List-Based History","text":"<p>For now, memory is a list that holds conversation history. Simple, predictable, sufficient for most agents:</p> <pre><code>flow agent(input: String):\n    history = []\n    loop:\n        history = history + [f\"User: {input}\"]\n        context = history.join(\"\\n\")\n        response = think(context, system=\"You are a helpful assistant.\")\n        history = history + [f\"Assistant: {response}\"]\n        write(stdout, response)\n</code></pre>"},{"location":"docs/memory/#future-semantic-memory","title":"Future: Semantic Memory","text":"<p>When the runtime supports <code>remember()</code> and <code>recall()</code>, memory becomes intelligent:</p> <pre><code># memory.cog \u2014 reusable memory module\n\nflow extract_facts(text: String) -&gt; List[String]:\n    facts = think(text, format=\"List[String]\",\n        system=\"Extract key facts. Be specific and self-contained.\")\n    return facts\n\nflow memorize(text: String):\n    facts = extract_facts(text)\n    for fact in facts:\n        remember(fact)\n    write(stdout, f\"Stored {facts.length} facts\")\n\nflow answer(question: String) -&gt; String:\n    context = recall(question)\n    if context.length == 0:\n        return think(question)\n    return think(f\"Context: {context}\\n\\nQuestion: {question}\",\n        system=\"Answer using the provided context.\")\n</code></pre> <p>Then any agent imports it:</p> <pre><code>import \"memory.cog\"\n\nflow main(input: String):\n    if input.starts_with(\"remember:\"):\n        memorize(input.replace(\"remember:\", \"\").strip())\n    else:\n        write(stdout, answer(input))\n</code></pre>"},{"location":"docs/memory/#design-principles","title":"Design Principles","text":"Principle Meaning Strategy is logic What to store, when to retrieve \u2014 that's <code>.cog</code> code Engine is runtime Vector DB, embeddings, persistence \u2014 runtime builtins Swappable Different agents, different memory strategies, same engine Auditable Read the <code>.cog</code> file to see exactly what gets remembered"},{"location":"docs/memory/#roadmap","title":"Roadmap","text":"<ul> <li>[x] List-based conversation history</li> <li>[ ] <code>remember(fact: String)</code> \u2014 store a fact in semantic memory</li> <li>[ ] <code>recall(query: String)</code> \u2192 List[String] \u2014 retrieve relevant facts</li> <li>[ ] <code>forget(query: String)</code> \u2014 remove facts</li> <li>[ ] Memory consolidation (summarize + deduplicate)</li> <li>[ ] Memory persistence across sessions</li> <li>[x] <code>import \"memory.cog\"</code> \u2014 reusable memory module (import system implemented)</li> </ul>"},{"location":"docs/sdlc-process/","title":"Software Development Lifecycle \u2014 Spiral Process Model","text":"<p>A structured process from vision to delivery with explicit feedback loops, escalation rules, and incremental delivery.</p>"},{"location":"docs/sdlc-process/#the-spiral","title":"The Spiral","text":"<p>Every iteration delivers a vertical slice \u2014 thin but complete. Each phase can refine within itself or escalate to an earlier phase.</p> <pre><code>graph TD\n    V[Vision] --&gt; R[Requirements]\n    R --&gt; A[Architecture]\n    A --&gt; D[Design]\n    D --&gt; I[Implementation]\n    I --&gt; VF[Verification]\n    VF --&gt; DL[Delivery]\n    DL --&gt; O[Operations &amp; Learning]\n\n    O --&gt;|next iteration| V\n\n    R --&gt;|refine| R\n    A --&gt;|refine| A\n    D --&gt;|refine| D\n    I --&gt;|refine| I\n    VF --&gt;|refine| VF\n\n    I --&gt;|escalate| D\n    I --&gt;|escalate| A\n    VF --&gt;|escalate| I\n    VF --&gt;|escalate| D\n    D --&gt;|escalate| A\n    D --&gt;|escalate| R\n    A --&gt;|escalate| R\n\n    style V fill:#4a9eff,color:#fff\n    style O fill:#4a9eff,color:#fff\n    style R fill:#5bb563,color:#fff\n    style A fill:#5bb563,color:#fff\n    style D fill:#5bb563,color:#fff\n    style I fill:#e8a838,color:#fff\n    style VF fill:#e8a838,color:#fff\n    style DL fill:#e05252,color:#fff</code></pre>"},{"location":"docs/sdlc-process/#phase-outcomes","title":"Phase Outcomes","text":"<p>Every phase has exactly three possible outcomes:</p> <pre><code>graph LR\n    P[Phase N] --&gt;|gate passes| N[Phase N+1]\n    P --&gt;|needs work| P\n    P --&gt;|assumption broke| E[Earlier Phase]\n\n    style P fill:#5bb563,color:#fff\n    style N fill:#4a9eff,color:#fff\n    style E fill:#e05252,color:#fff</code></pre> <ol> <li>Pass gate \u2192 proceed to next phase</li> <li>Refine \u2192 loop within current phase until gate passes</li> <li>Escalate \u2192 return to a specific earlier phase with explicit reason</li> </ol>"},{"location":"docs/sdlc-process/#iteration-strategy","title":"Iteration Strategy","text":"<pre><code>graph LR\n    subgraph Iteration 1\n        direction LR\n        V1[Smallest useful thing] --&gt; D1[Prove architecture end-to-end]\n    end\n    subgraph Iteration 2\n        direction LR\n        V2[Add capability] --&gt; D2[Deepen quality]\n    end\n    subgraph Iteration 3\n        direction LR\n        V3[Broaden scope] --&gt; D3[Harden for production]\n    end\n\n    Iteration 1 --&gt; Iteration 2 --&gt; Iteration 3</code></pre> <p>Each iteration is a full spiral \u2014 vision through delivery. Never batch phases across iterations (that's waterfall in disguise).</p>"},{"location":"docs/sdlc-process/#phase-1-vision-requirements","title":"Phase 1: Vision \u2192 Requirements","text":"<p>Input: A vision statement \u2014 what we want to exist and why.</p> <p>Process: 1. Break the vision into user-facing capabilities (what, not how) 2. For each capability, define acceptance criteria \u2014 how do we know it's done? 3. Identify constraints: performance, security, compliance, budget, timeline 4. Prioritize: what's essential for this iteration vs what can wait? 5. Identify risks and unknowns \u2014 what could kill this?</p> <p>Output: Prioritized capabilities, acceptance criteria, constraints, known risks.</p> <p>Gate: Requirements are clear, testable, and scoped to one iteration.</p> <p>Failure mode: Vague requirements. No prioritization. Scope too large for one iteration. Gold-plating.</p>"},{"location":"docs/sdlc-process/#phase-2-requirements-architecture","title":"Phase 2: Requirements \u2192 Architecture","text":"<p>Input: Approved requirements for this iteration.</p> <p>Process: 1. Identify system boundaries \u2014 what's in scope, what's external? 2. Decompose into components with clear responsibilities 3. Define interfaces between components \u2014 contracts, not implementations 4. Choose technology based on constraints, not trends 5. Design for failure: what happens when each component fails? 6. Design for change: what's most likely to change? Isolate it. 7. Write ADRs for every non-obvious choice</p> <p>Output: Component diagram, interface contracts, ADRs.</p> <p>Gate: Architecture satisfies all requirements. Failure modes handled. As simple as possible.</p> <p>Escalate to Requirements when: A requirement is technically infeasible or cost-prohibitive.</p> <p>Failure mode: Over-engineering. Distributed when monolith suffices. No ADRs.</p>"},{"location":"docs/sdlc-process/#phase-3-architecture-design","title":"Phase 3: Architecture \u2192 Design","text":"<p>Input: Approved architecture.</p> <p>Process: 1. For each component: modules, data models, algorithms 2. Design the data model \u2014 hardest part, get it right 3. Define error handling strategy 4. Define testing strategy per component 5. Design API surfaces: minimal, consistent, hard to misuse 6. Write technical specifications</p> <p>Output: Technical specifications, data models, API contracts, testing strategy.</p> <p>Gate: Data model is right. APIs are minimal. Testing strategy is realistic.</p> <p>Escalate to Architecture when: Component boundaries are wrong \u2014 discovered during detailed design. Escalate to Requirements when: Acceptance criteria are ambiguous or contradictory.</p> <p>Failure mode: Leaky abstractions. Data model compromises. No testing strategy.</p>"},{"location":"docs/sdlc-process/#phase-4-design-implementation","title":"Phase 4: Design \u2192 Implementation","text":"<p>Input: Approved technical specifications.</p> <p>Process: 1. Break into work units \u2014 each 1-3 days, with clear done criteria 2. Implement bottom-up: shared utilities \u2192 core logic \u2192 integration 3. Write tests alongside code, not after 4. Every work unit: code + tests + docs 5. Commits atomic: one logical change, always green 6. Code review on every change 7. Merge to main daily 8. Refactor as you go</p> <p>Output: Working, tested, documented code on main branch.</p> <p>Gate: All tests pass. Code review approved. Documentation updated.</p> <p>Escalate to Design when: Spec has a gap or contradiction discovered during implementation. Escalate to Architecture when: Performance or integration issues reveal wrong component boundaries.</p> <p>Failure mode: Big-bang integration. Tests written after. Deferred refactoring.</p>"},{"location":"docs/sdlc-process/#phase-5-implementation-verification","title":"Phase 5: Implementation \u2192 Verification","text":"<p>Input: Code that passes unit and integration tests.</p> <p>Process: 1. Full test suite: unit, integration, end-to-end 2. Verify against acceptance criteria from Phase 1 \u2014 every criterion, explicitly 3. Performance testing against defined constraints 4. Security review 5. Chaos testing: kill components, inject failures 6. User acceptance testing: real users, real scenarios</p> <p>Output: Verification report. All criteria met or explicitly deferred with justification.</p> <p>Gate: Ship/no-ship decision. No critical issues open. Runbook exists.</p> <p>Escalate to Implementation when: Bug found \u2014 fix and re-verify. Escalate to Design when: Systemic quality issue reveals design flaw.</p> <p>Failure mode: Only testing happy paths. Skipping security. No chaos testing.</p>"},{"location":"docs/sdlc-process/#phase-6-verification-delivery","title":"Phase 6: Verification \u2192 Delivery","text":"<p>Input: Verified, ship-ready build.</p> <p>Process: 1. Reproducible build artifacts, versioned, signed 2. Write/update runbook 3. Deploy to staging, smoke test 4. Deploy to production: canary \u2192 gradual \u2192 full 5. Monitor: error rates, latency, resources vs baseline 6. Bake period: no new deploys, watch for regressions</p> <p>Output: Running production system, monitoring, runbook, verified rollback plan.</p> <p>Gate: Bake period clean. Monitoring nominal.</p> <p>Escalate to Verification when: Staging reveals issue not caught in verification. Escalate to Implementation when: Production issue requires code fix \u2192 rollback first.</p> <p>Failure mode: No canary. No rollback plan. No bake period.</p>"},{"location":"docs/sdlc-process/#phase-7-operations-learning","title":"Phase 7: Operations &amp; Learning","text":"<p>Input: Running production system.</p> <p>Process: 1. Monitor continuously: SLOs, error budgets, user feedback 2. Incident response: detect \u2192 triage \u2192 mitigate \u2192 root cause \u2192 prevent 3. Blameless post-mortems with actionable follow-ups 4. Track tech debt: log it, schedule the fix 5. Measure outcomes, not output 6. Retrospective: what worked, what didn't, what changes?</p> <p>Output: Operational metrics, incident reports, tech debt register, learnings for next iteration.</p> <p>Feeds back to Phase 1: Learnings become input for the next iteration's vision.</p> <pre><code>graph TD\n    O[Operations] --&gt;|users not using feature X| R[Revisit Requirements]\n    O --&gt;|incidents in component Y| A[Revisit Architecture]\n    O --&gt;|performance below target| D[Revisit Design]\n    O --&gt;|new user need discovered| V[New Vision Input]\n\n    style O fill:#4a9eff,color:#fff\n    style R fill:#5bb563,color:#fff\n    style A fill:#5bb563,color:#fff\n    style D fill:#5bb563,color:#fff\n    style V fill:#4a9eff,color:#fff</code></pre>"},{"location":"docs/sdlc-process/#escalation-rules","title":"Escalation Rules","text":"<pre><code>graph TD\n    E[Escalation Triggered] --&gt; S[State: which phase, what broke, proposed change]\n    S --&gt; RP[Revisited phase re-runs its gate]\n    RP --&gt; DV[All downstream phases re-validate]\n    DV --&gt; C{Escalation count high?}\n    C --&gt;|yes| RT[Rethink scope \u2014 wrong decomposition]\n    C --&gt;|no| Continue[Continue from revisited phase]\n\n    style E fill:#e05252,color:#fff\n    style RT fill:#e05252,color:#fff\n    style Continue fill:#5bb563,color:#fff</code></pre> <ol> <li>Explicit: Must state which phase to revisit, what assumption broke, and proposed change</li> <li>Cascading: The revisited phase re-runs its gate; all downstream phases re-validate</li> <li>Tracked: Count escalations \u2014 too many means wrong decomposition, rethink scope</li> <li>Never silent: Deviating without escalating is the most dangerous failure mode</li> </ol>"},{"location":"docs/sdlc-process/#cross-cutting-principles","title":"Cross-Cutting Principles","text":"<ol> <li>Every phase has a gate. Don't proceed without passing. Gates prevent compounding errors.</li> <li>Feedback is explicit. Refinement loops and escalations are tracked, not hidden.</li> <li>Fail fast, fail small. Short iterations, quick feedback. A wrong decision found early costs 10x less.</li> <li>Automate repetition. Testing, deployment, monitoring \u2014 human judgment for design.</li> <li>Single source of truth. One place for requirements, architecture, runbooks. Never two copies.</li> <li>Optimize for change. Requirements will change. Design for expected change, not all possible change.</li> <li>Quality is built in. Every phase, not bolted on at the end.</li> <li>Vertical slices. Each iteration is thin but complete \u2014 vision through delivery.</li> </ol>"},{"location":"docs/tracing/","title":"Tracing &amp; Diagnostics","text":"<p>Cognos has built-in structured tracing for monitoring and troubleshooting agent execution.</p>"},{"location":"docs/tracing/#quick-start","title":"Quick Start","text":"<pre><code>cognos run --trace trace.jsonl file.cog\n</code></pre> <p>Every runtime event is written as one JSON line to the trace file.</p>"},{"location":"docs/tracing/#trace-levels","title":"Trace Levels","text":"Field Metrics (default) Full <code>event</code>, <code>ts</code>, <code>elapsed_ms</code>, <code>turn</code> \u2705 \u2705 llm_call <code>model</code>, <code>provider</code>, <code>latency_ms</code> \u2705 \u2705 <code>prompt_chars</code>, <code>response_chars</code> \u2705 \u2705 <code>has_tool_calls</code>, <code>error</code> \u2705 \u2705 <code>prompt</code>, <code>response</code>, <code>system</code> \u274c \u2705 shell_exec <code>command</code>, <code>latency_ms</code>, <code>exit_code</code> \u2705 \u2705 <code>output_chars</code> \u2705 \u2705 <code>output</code> \u274c \u2705 io <code>op</code>, <code>handle</code>, <code>path</code>, <code>bytes</code> \u2705 \u2705 <code>content</code> \u274c \u2705 tool_exec <code>tool</code>, <code>args</code>, <code>latency_ms</code> \u2705 \u2705 <code>result_chars</code>, <code>success</code>, <code>error</code> \u2705 \u2705 context <code>history_len</code>, <code>context_chars</code> \u2705 \u2705 error <code>category</code>, <code>message</code>, <code>flow</code> \u2705 \u2705 <p>Metrics is safe for production \u2014 no sensitive data leaked. Use it for performance monitoring and alerting.</p> <p>Full includes all content \u2014 prompts, responses, user input, file contents, shell output. Use it for debugging and session reconstruction. File reads are capped at 1000 chars.</p>"},{"location":"docs/tracing/#trace-events","title":"Trace Events","text":""},{"location":"docs/tracing/#llm_call","title":"llm_call","text":"<p>Emitted for every <code>think()</code> call.</p> <pre><code>{\n  \"ts\": \"1770852240\",\n  \"elapsed_ms\": 4066,\n  \"turn\": 1,\n  \"event\": \"llm_call\",\n  \"model\": \"claude-sonnet-4-20250514\",\n  \"provider\": \"claude-cli\",\n  \"latency_ms\": 4066,\n  \"prompt_chars\": 27,\n  \"response_chars\": 115,\n  \"has_tool_calls\": true,\n  \"error\": null\n}\n</code></pre> Field Description <code>model</code> Model name passed to <code>think()</code> <code>provider</code> <code>claude-cli</code>, <code>anthropic</code>, <code>ollama</code>, or <code>mock</code> <code>latency_ms</code> Time from request to response <code>prompt_chars</code> Characters sent to the LLM <code>response_chars</code> Characters received <code>has_tool_calls</code> Whether the LLM requested tool calls <code>error</code> Error message if the call failed, null otherwise"},{"location":"docs/tracing/#shell_exec","title":"shell_exec","text":"<p>Emitted for every <code>__exec_shell__()</code> call.</p> <pre><code>{\n  \"event\": \"shell_exec\",\n  \"command\": \"date | head -50\",\n  \"latency_ms\": 2,\n  \"exit_code\": 0,\n  \"output_chars\": 32\n}\n</code></pre> Field Description <code>command</code> The shell command executed <code>latency_ms</code> Execution time <code>exit_code</code> Process exit code (0 = success) <code>output_chars</code> Characters in stdout"},{"location":"docs/tracing/#tool_exec","title":"tool_exec","text":"<p>Emitted when <code>invoke()</code> or <code>exec()</code> (from <code>lib/exec.cog</code>) invokes a tool flow.</p> <pre><code>{\n  \"event\": \"tool_exec\",\n  \"tool\": \"search\",\n  \"args\": \"{\\\"query\\\": \\\"weather amsterdam\\\"}\",\n  \"latency_ms\": 150,\n  \"result_chars\": 200,\n  \"success\": true,\n  \"error\": null\n}\n</code></pre>"},{"location":"docs/tracing/#flow_start-flow_end","title":"flow_start / flow_end","text":"<p>Emitted when a flow begins and ends execution.</p> <pre><code>{\"event\": \"flow_start\", \"flow\": \"main\"}\n{\"event\": \"flow_end\", \"flow\": \"main\", \"duration_ms\": 15000}\n</code></pre>"},{"location":"docs/tracing/#io","title":"io","text":"<p>Emitted for <code>read()</code> and <code>write()</code> operations.</p> <pre><code>{\n  \"event\": \"io\",\n  \"op\": \"read\",\n  \"handle\": \"file\",\n  \"path\": \"data.txt\",\n  \"bytes\": 4096\n}\n</code></pre>"},{"location":"docs/tracing/#context","title":"context","text":"<p>Emitted to track conversation context growth.</p> <pre><code>{\n  \"event\": \"context\",\n  \"history_len\": 8,\n  \"context_chars\": 3200\n}\n</code></pre>"},{"location":"docs/tracing/#error","title":"error","text":"<p>Emitted when a runtime error occurs.</p> <pre><code>{\n  \"event\": \"error\",\n  \"category\": \"runtime\",\n  \"message\": \"cannot iterate over 42 (type: Int)\",\n  \"flow\": \"main\"\n}\n</code></pre>"},{"location":"docs/tracing/#common-fields","title":"Common Fields","text":"<p>Every event includes:</p> Field Description <code>ts</code> Unix timestamp (seconds) <code>elapsed_ms</code> Milliseconds since program start <code>turn</code> Conversation turn number"},{"location":"docs/tracing/#analyzing-traces","title":"Analyzing Traces","text":""},{"location":"docs/tracing/#with-jq","title":"With jq","text":"<pre><code># All LLM calls with latency\njq 'select(.event == \"llm_call\") | {model, latency_ms, prompt_chars, response_chars}' trace.jsonl\n\n# Total LLM time\njq -s '[.[] | select(.event == \"llm_call\") | .latency_ms] | add' trace.jsonl\n\n# Tool calls only\njq 'select(.event == \"tool_exec\")' trace.jsonl\n\n# Errors\njq 'select(.event == \"error\")' trace.jsonl\n\n# Shell commands with exit codes\njq 'select(.event == \"shell_exec\") | {command, exit_code, latency_ms}' trace.jsonl\n</code></pre>"},{"location":"docs/tracing/#summary-report","title":"Summary report","text":"<pre><code># Count events by type\njq -s 'group_by(.event) | map({event: .[0].event, count: length})' trace.jsonl\n\n# Average LLM latency by provider\njq -s '[.[] | select(.event == \"llm_call\")] | group_by(.provider) | map({provider: .[0].provider, avg_ms: (map(.latency_ms) | add / length)})' trace.jsonl\n</code></pre>"},{"location":"docs/tracing/#cli-reference","title":"CLI Reference","text":"<pre><code>cognos run --trace &lt;path&gt; [--allow-shell] &lt;file.cog&gt;\n</code></pre> Flag Description <code>--trace &lt;path&gt;</code> Write JSONL trace events to file <code>--trace-level metrics\\|full</code> Trace detail level (default: metrics) <code>--allow-shell</code> Enable <code>__exec_shell__()</code> primitive <code>-v</code> / <code>-vv</code> / <code>-vvv</code> Log verbosity (info/debug/trace) to stderr <p>Tracing and logging are independent \u2014 you can use both:</p> <pre><code>cognos run -v --trace trace.jsonl --allow-shell agent.cog\n</code></pre>"},{"location":"spec/compilation/","title":"Cognos Compilation Specification","text":""},{"location":"spec/compilation/#overview","title":"Overview","text":"<p>Cognos source files (<code>.cog</code>) compile to the same internal <code>StageDef</code> representation that the Neocognos kernel already understands and executes. This design choice provides several key benefits:</p> <ol> <li>No kernel changes required - The existing Neocognos runtime works unchanged</li> <li>Feature parity - Cognos can express anything that YAML workflows can</li> <li>Interoperability - Cognos and YAML workflows can call each other</li> <li>Proven runtime - Leverages the mature, battle-tested kernel</li> </ol>"},{"location":"spec/compilation/#compilation-pipeline","title":"Compilation Pipeline","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 .cog source \u2502 =&gt; \u2502   Parser   \u2502 =&gt; \u2502   Compiler  \u2502 =&gt; \u2502  StageDef    \u2502\n\u2502    files    \u2502    \u2502    (AST)   \u2502    \u2502 (semantic)  \u2502    \u2502 (JSON/binary)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                              \u2502\n                                                              v\n                                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                                    \u2502  Neocognos   \u2502\n                                                    \u2502   Kernel     \u2502\n                                                    \u2502  (Runtime)   \u2502\n                                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"spec/compilation/#phase-1-parsing","title":"Phase 1: Parsing","text":"<ul> <li>Lexical analysis breaks source into tokens</li> <li>Parser builds Abstract Syntax Tree (AST) using the PEG grammar</li> <li>Syntax errors are caught and reported with precise location information</li> </ul>"},{"location":"spec/compilation/#phase-2-semantic-analysis","title":"Phase 2: Semantic Analysis","text":"<ul> <li>Type checking ensures all expressions are well-typed</li> <li>Symbol resolution links identifiers to their definitions</li> <li>Flow dependency analysis enables proper compilation order</li> <li>Semantic errors are caught and reported</li> </ul>"},{"location":"spec/compilation/#phase-3-code-generation","title":"Phase 3: Code Generation","text":"<ul> <li>AST is lowered to <code>StageDef</code> representation</li> <li>Cognos constructs map to equivalent kernel primitives</li> <li>Optimization passes may be applied</li> </ul>"},{"location":"spec/compilation/#cognos-to-kernel-mapping","title":"Cognos to Kernel Mapping","text":""},{"location":"spec/compilation/#flow-definitions","title":"Flow Definitions","text":"<pre><code>flow example_flow(param: String) -&gt; String:\n    result = think(param)\n    return result\n</code></pre> <p>Compiles to a <code>StageDef</code> with: - Input schema defining the parameter structure - Step definitions for each statement - Output schema defining the return type</p>"},{"location":"spec/compilation/#built-in-functions","title":"Built-in Functions","text":"Cognos Function Kernel Implementation <code>think()</code> LLM inference step with prompt construction <code>act()</code> Tool execution step <code>receive()</code> Input binding from runtime context <code>emit()</code> Output emission to runtime context <code>run()</code> Shell command execution step <code>read_file()</code> File system read operation <code>write_file()</code> File system write operation <code>remember()</code> Memory storage operation <code>recall()</code> Memory retrieval operation <code>log()</code> Debug output step"},{"location":"spec/compilation/#control-flow","title":"Control Flow","text":""},{"location":"spec/compilation/#conditionals","title":"Conditionals","text":"<pre><code>if condition:\n    statement1\nelse:\n    statement2\n</code></pre> <p>Compiles to conditional step execution in the kernel with proper branching logic.</p>"},{"location":"spec/compilation/#loops","title":"Loops","text":"<pre><code>loop max=10:\n    statement\n</code></pre> <p>Compiles to bounded loop construct with automatic iteration tracking and termination.</p>"},{"location":"spec/compilation/#parallel-execution","title":"Parallel Execution","text":"<pre><code>a, b = parallel:\n    operation1()\n    operation2()\n</code></pre> <p>Compiles to parallel execution group with result collection and synchronization.</p>"},{"location":"spec/compilation/#type-system-integration","title":"Type System Integration","text":"<p>Cognos types map to kernel type schemas:</p> <ul> <li>Primitive types (<code>String</code>, <code>Bool</code>, <code>Int</code>, <code>Float</code>) map to corresponding JSON schema primitives</li> <li>Container types (<code>List[T]</code>, <code>Map[K,V]</code>) map to JSON schema arrays and objects</li> <li>Custom types compile to structured JSON schemas with field validation</li> <li>Optional types use JSON schema nullable properties</li> </ul>"},{"location":"spec/compilation/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    risky_operation()\ncatch error:\n    handle_error(error)\n</code></pre> <p>Compiles to kernel error handling mechanisms with proper exception propagation and recovery.</p>"},{"location":"spec/compilation/#compilation-artifacts","title":"Compilation Artifacts","text":""},{"location":"spec/compilation/#input-format","title":"Input Format","text":"<ul> <li>Source files: <code>*.cog</code></li> <li>Configuration: <code>cognos.toml</code> (optional)</li> </ul>"},{"location":"spec/compilation/#output-format","title":"Output Format","text":"<ul> <li>Primary output: <code>StageDef</code> JSON/binary</li> <li>Debug symbols: Source maps for runtime debugging</li> <li>Type information: Schema definitions for validation</li> </ul>"},{"location":"spec/compilation/#example-output-structure","title":"Example Output Structure","text":"<pre><code>{\n  \"stage_id\": \"example_flow\",\n  \"input_schema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"param\": {\"type\": \"string\"}\n    },\n    \"required\": [\"param\"]\n  },\n  \"steps\": [\n    {\n      \"id\": \"step_1\",\n      \"type\": \"llm_call\",\n      \"config\": {\n        \"prompt_template\": \"{{param}}\",\n        \"system_prompt\": \"\",\n        \"tools\": []\n      }\n    }\n  ],\n  \"output_schema\": {\n    \"type\": \"string\"\n  }\n}\n</code></pre>"},{"location":"spec/compilation/#implementation-details","title":"Implementation Details","text":""},{"location":"spec/compilation/#compiler-architecture","title":"Compiler Architecture","text":"<p>The Cognos compiler is implemented in Rust and consists of several modules:</p> <pre><code>cognos-compiler/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lexer.rs          # Tokenization\n\u2502   \u251c\u2500\u2500 parser.rs         # AST construction\n\u2502   \u251c\u2500\u2500 ast.rs            # AST node definitions\n\u2502   \u251c\u2500\u2500 analyzer.rs       # Semantic analysis\n\u2502   \u251c\u2500\u2500 typechecker.rs    # Type system\n\u2502   \u251c\u2500\u2500 codegen.rs        # StageDef generation\n\u2502   \u251c\u2500\u2500 error.rs          # Error handling\n\u2502   \u2514\u2500\u2500 main.rs           # CLI interface\n\u251c\u2500\u2500 tests/                # Test suite\n\u2514\u2500\u2500 Cargo.toml\n</code></pre>"},{"location":"spec/compilation/#cli-interface","title":"CLI Interface","text":"<pre><code># Compile a single file\ncognos compile example.cog -o example.stage.json\n\n# Compile a project\ncognos build\n\n# Type check only\ncognos check *.cog\n\n# Watch mode for development\ncognos watch src/\n</code></pre>"},{"location":"spec/compilation/#configuration","title":"Configuration","text":"<p>Optional <code>cognos.toml</code> for project-level settings:</p> <pre><code>[project]\nname = \"my-workflow\"\nversion = \"0.1.0\"\n\n[compiler]\ntarget = \"neocognos-v1\"\noptimization_level = 1\n\n[output]\nformat = \"json\"  # or \"binary\"\ncompress = true\ninclude_debug = false\n</code></pre>"},{"location":"spec/compilation/#future-enhancements","title":"Future Enhancements","text":""},{"location":"spec/compilation/#lsp-server","title":"LSP Server","text":"<p>A Language Server Protocol implementation will provide: - Real-time syntax highlighting - Type information on hover - Auto-completion - Error squiggles - Refactoring support</p>"},{"location":"spec/compilation/#tree-sitter-grammar","title":"Tree-sitter Grammar","text":"<p>A tree-sitter grammar will enable: - Syntax highlighting in editors - Structural navigation - Code folding - AST-based tooling</p>"},{"location":"spec/compilation/#advanced-optimizations","title":"Advanced Optimizations","text":"<p>Future compiler versions may include: - Dead code elimination - Common subexpression elimination - Flow inlining for simple cases - Parallel execution optimization</p>"},{"location":"spec/compilation/#debugging-support","title":"Debugging Support","text":"<p>Integration with the kernel debugger for: - Breakpoint support - Variable inspection - Step-through execution - Flow call stack traces</p>"},{"location":"spec/compilation/#backward-compatibility","title":"Backward Compatibility","text":"<p>The compilation target (<code>StageDef</code>) is designed to be stable across kernel versions. This ensures that: - Compiled Cognos workflows continue working as the kernel evolves - Mixed deployments (Cognos + YAML) are fully supported - Migration from YAML to Cognos can be gradual</p>"},{"location":"spec/compilation/#alternative-syntaxes","title":"Alternative Syntaxes","text":"<p>While Cognos provides a clean imperative syntax, the kernel's <code>StageDef</code> format also supports other potential frontends: - YAML workflows (existing) - Functional language frontends - Visual workflow builders - Domain-specific languages</p> <p>This flexibility allows teams to choose the syntax that best fits their workflow and expertise while sharing the same robust execution engine.</p>"},{"location":"spec/language-spec/","title":"Cognos Language Specification","text":"<p>Version: 0.5.0</p>"},{"location":"spec/language-spec/#1-introduction","title":"1. Introduction","text":"<p>Cognos is a programming language for agentic workflows. It provides deterministic control structures around non-deterministic computation (LLM calls). The LLM is a co-processor \u2014 you call it via <code>think()</code>, but everything else is explicit, typed, and testable.</p>"},{"location":"spec/language-spec/#11-design-principles","title":"1.1 Design Principles","text":"<ul> <li>Start with nothing, add what you need. No accidental complexity.</li> <li>Channel agnostic. Flows declare what input they need, not where it comes from.</li> <li>The LLM is a co-processor. <code>think()</code> is the only non-deterministic primitive.</li> <li>Environment agnostic. Same <code>.cog</code> runs in production or against a mock.</li> <li>Sandboxed by design. Only builtins can interact with the outside world.</li> <li>Builtins are atomic. Rust builtins perform one I/O operation. Orchestration, loops, and decision-making belong in <code>.cog</code> flows.</li> <li>Behaviors in language, not runtime. Agent behaviors (retry, tool loops, memory) are <code>.cog</code> flows, not Rust code.</li> <li>One feature, multiple use cases. Prefer one general mechanism over multiple specialized ones.</li> <li>Testability first. Every agent testable without LLM, network, or filesystem. Mocks are first-class.</li> <li>Lean core runtime. Cognos is a domain language for agents, not a general-purpose language. Think, act, observe, remember \u2014 everything else is out of scope.</li> <li>Platform portable. <code>.cog</code> files run anywhere the interpreter compiles.</li> </ul>"},{"location":"spec/language-spec/#2-types","title":"2. Types","text":""},{"location":"spec/language-spec/#21-primitive-types","title":"2.1 Primitive Types","text":"Type Literal Example <code>String</code> <code>\"...\"</code> or <code>f\"...{expr}...\"</code> <code>\"hello\"</code>, <code>f\"hi {name}\"</code> <code>Int</code> digits <code>42</code>, <code>-5</code> <code>Float</code> digits.digits <code>3.14</code> <code>Bool</code> <code>true</code> / <code>false</code> <code>true</code>"},{"location":"spec/language-spec/#22-collection-types","title":"2.2 Collection Types","text":"Type Literal Example <code>List[T]</code> <code>[a, b, c]</code> <code>[1, 2, 3]</code> <code>Map[K,V]</code> <code>{\"k\": v}</code> <code>{\"name\": \"cognos\"}</code>"},{"location":"spec/language-spec/#23-special-types","title":"2.3 Special Types","text":"Type Description <code>None</code> Returned by <code>write()</code>, <code>log()</code>, <code>save()</code>. No literal. <code>Handle</code> I/O endpoint: <code>stdin</code>, <code>stdout</code>, or <code>file(\"path\")</code> <code>Module</code> Built-in module: <code>http</code>"},{"location":"spec/language-spec/#24-custom-types","title":"2.4 Custom Types","text":"<pre><code>type Review:\n    score: Int\n    summary: String\n    tags: List\n</code></pre> <p>Used with <code>think(input, format=\"Review\")</code> to get structured LLM output.</p>"},{"location":"spec/language-spec/#241-generic-type-validation","title":"2.4.1 Generic Type Validation","text":"<p>List and Map types support inner type parameters for validation:</p> <pre><code>type Insight:\n    text: String\n    score: Int\n\ntype Review:\n    score: Int\n    insights: List[Insight]    # each element validated as Insight\n    tags: List                  # unvalidated (any list)\n    metadata: Map[String, Int]  # values validated as Int\n</code></pre> <p>When <code>think(input, format=\"Review\")</code> returns data, <code>List[Insight]</code> validates every element against the <code>Insight</code> type definition. <code>Map[String, Int]</code> validates all values are integers.</p>"},{"location":"spec/language-spec/#242-optional-fields","title":"2.4.2 Optional Fields","text":"<p>Fields can be marked optional with <code>?</code> \u2014 they may be absent from LLM responses:</p> <pre><code>type Config:\n    name: String\n    description?: String    # may be missing\n    timeout?: Int           # may be missing\n</code></pre> <p>Optional fields are not included in the \"required\" set during validation. If present, they are still type-checked.</p>"},{"location":"spec/language-spec/#243-enum-types","title":"2.4.3 Enum Types","text":"<p>Enum types restrict a field to a fixed set of string values:</p> <pre><code>type Severity: \"low\" | \"medium\" | \"high\" | \"critical\"\n\ntype Issue:\n    title: String\n    severity: Severity\n</code></pre> <p>Enum values are validated \u2014 if the LLM returns a value not in the set, validation fails.</p>"},{"location":"spec/language-spec/#25-truthiness","title":"2.5 Truthiness","text":"Falsy Truthy <code>false</code>, <code>0</code>, <code>0.0</code>, <code>\"\"</code>, <code>[]</code>, <code>{}</code>, <code>None</code> Everything else"},{"location":"spec/language-spec/#26-type-coercion","title":"2.6 Type Coercion","text":"<p>Mixed <code>Int</code>/<code>Float</code> arithmetic auto-promotes: <code>1 + 2.5 \u2192 3.5</code></p>"},{"location":"spec/language-spec/#3-imports","title":"3. Imports","text":"<pre><code>import \"path/to/module.cog\"\n</code></pre> <ul> <li>Must appear at the top of the file, before types and flows</li> <li>Paths resolve relative to the importing file's directory</li> <li>Recursive imports supported</li> <li>Imported flows and types are registered in the current scope</li> <li>Last import wins on name collisions</li> </ul>"},{"location":"spec/language-spec/#4-flows","title":"4. Flows","text":"<p>Flows are the fundamental unit of composition.</p> <pre><code>flow main():\n    write(stdout, \"Hello, World!\")\n\nflow greet(name: String) -&gt; String:\n    return f\"Hello, {name}!\"\n\nflow assistant(input: String):\n    response = think(input, model=\"qwen2.5:7b\")\n    write(stdout, response)\n</code></pre>"},{"location":"spec/language-spec/#41-docstrings","title":"4.1 Docstrings","text":"<p>The first string literal in a flow body is its description (used as tool description):</p> <pre><code>flow search(query: String) -&gt; String:\n    \"Search the web for information\"\n    return http.get(f\"https://api.example.com/search?q={query}\")\n</code></pre>"},{"location":"spec/language-spec/#42-input-binding","title":"4.2 Input Binding","text":"Context How params are bound <code>cognos run file.cog</code> Read from stdin Neocognos TUI Bound from user message API call Bound from request body Flow-to-flow call Passed as arguments As tool Bound from LLM tool call arguments"},{"location":"spec/language-spec/#43-flow-composition","title":"4.3 Flow Composition","text":"<pre><code>flow add(a: Int, b: Int) -&gt; Int:\n    return a + b\n\nflow main():\n    write(stdout, add(2, 3))    # \u2192 5\n</code></pre>"},{"location":"spec/language-spec/#44-flows-as-tools","title":"4.4 Flows as Tools","text":"<p>Flows can be passed to <code>think()</code> as tools. The interpreter auto-generates JSON schemas from flow signatures:</p> <pre><code>import \"lib/exec.cog\"\n\nflow shell(command: String) -&gt; String:\n    \"Execute a sandboxed shell command\"\n    return __exec_shell__(command)\n\nflow main():\n    response = think(\"What time is it?\",\n        model=\"claude-sonnet-4-20250514\",\n        tools=[\"shell\"])\n    if response[\"has_tool_calls\"]:\n        response = exec(response, tools=[\"shell\"])\n    write(stdout, response)\n</code></pre>"},{"location":"spec/language-spec/#5-built-in-functions","title":"5. Built-in Functions","text":""},{"location":"spec/language-spec/#51-llm","title":"5.1 LLM","text":""},{"location":"spec/language-spec/#thinkcontext-model-system-tools-format-string-map","title":"<code>think(context, model=\"\", system=\"\", tools=[], format=\"\") -&gt; String | Map</code>","text":"<p>Invokes the LLM. The only non-deterministic primitive.</p> <pre><code># Simple call\nresponse = think(input)\n\n# With model and system prompt\nresponse = think(input, model=\"claude-sonnet-4-20250514\", system=\"Be concise.\")\n\n# With tools \u2014 returns Map with content + tool_calls\nresponse = think(input, tools=[\"shell\", \"search\"])\n\n# With structured output \u2014 returns Map matching type schema\nreview = think(code, format=\"Review\")\n</code></pre> <p>Model routing: <code>claude-*</code> \u2192 Claude CLI/API, anything else \u2192 Ollama.</p>"},{"location":"spec/language-spec/#invokename-args-value","title":"<code>invoke(name, args) -&gt; Value</code>","text":"<p>Calls a flow by string name with a Map of keyword arguments. This is the atomic primitive for dynamic dispatch.</p> <pre><code>result = invoke(\"shell\", {\"command\": \"date\"})\n# equivalent to: result = shell(command=\"date\")\n</code></pre> <p>Note: <code>exec()</code> (tool call execution from <code>think()</code> responses) has moved to the standard library at <code>lib/exec.cog</code>. Import it with <code>import \"lib/exec.cog\"</code>. See Standard Library below.</p>"},{"location":"spec/language-spec/#52-io","title":"5.2 I/O","text":""},{"location":"spec/language-spec/#readhandle-string","title":"<code>read(handle?) -&gt; String</code>","text":"<p>Reads from a handle. Default: <code>stdin</code>.</p> <pre><code>line = read(stdin)           # read one line from stdin\ncontent = read(file(\"data.txt\"))  # read entire file\n</code></pre>"},{"location":"spec/language-spec/#writehandle-content","title":"<code>write(handle, content)</code>","text":"<p>Writes to a handle.</p> <pre><code>write(stdout, \"Hello!\")           # print to stdout\nwrite(file(\"out.txt\"), content)   # write to file\n</code></pre>"},{"location":"spec/language-spec/#filepath-handle","title":"<code>file(path) -&gt; Handle</code>","text":"<p>Creates a file handle.</p> <pre><code>write(file(\"output.txt\"), \"data\")\ncontent = read(file(\"input.txt\"))\n</code></pre>"},{"location":"spec/language-spec/#53-persistence","title":"5.3 Persistence","text":""},{"location":"spec/language-spec/#savepath-value","title":"<code>save(path, value)</code>","text":"<p>Serializes any Cognos value to a JSON file.</p> <pre><code>save(\"state.json\", {\"history\": history, \"count\": 42})\n</code></pre>"},{"location":"spec/language-spec/#loadpath-value","title":"<code>load(path) -&gt; Value</code>","text":"<p>Deserializes a JSON file back to a Cognos value.</p> <pre><code>state = load(\"state.json\")\n</code></pre>"},{"location":"spec/language-spec/#54-shell","title":"5.4 Shell","text":""},{"location":"spec/language-spec/#__exec_shell__command-string","title":"<code>__exec_shell__(command) -&gt; String</code>","text":"<p>Low-level shell primitive. Requires <code>--allow-shell</code> flag.</p> <p>Typically wrapped in a user-defined flow for sandboxing:</p> <pre><code>flow shell(command: String) -&gt; String:\n    \"Execute a sandboxed shell command. Output limited to 50 lines.\"\n    return __exec_shell__(f\"{command} | head -50\")\n</code></pre>"},{"location":"spec/language-spec/#55-logging","title":"5.5 Logging","text":""},{"location":"spec/language-spec/#logmessage","title":"<code>log(message)</code>","text":"<p>Outputs to stderr (debug, not user-visible).</p>"},{"location":"spec/language-spec/#printvalue","title":"<code>print(value)</code>","text":"<p>Alias for <code>log()</code>.</p>"},{"location":"spec/language-spec/#56-built-in-variables","title":"5.6 Built-in Variables","text":"Variable Type Description <code>stdin</code> Handle Standard input handle <code>stdout</code> Handle Standard output handle <code>http</code> Module HTTP client"},{"location":"spec/language-spec/#6-native-modules","title":"6. Native Modules","text":""},{"location":"spec/language-spec/#61-http","title":"6.1 <code>http</code>","text":"Function Description <code>http.get(url)</code> HTTP GET, returns body as String <code>http.post(url, body)</code> HTTP POST, returns body as String"},{"location":"spec/language-spec/#7-operators","title":"7. Operators","text":""},{"location":"spec/language-spec/#71-arithmetic","title":"7.1 Arithmetic","text":"<p><code>+</code> (add/concat lists/strings), <code>-</code>, <code>*</code>, <code>/</code>, unary <code>-</code></p> <p><code>Int + Float</code> \u2192 <code>Float</code> (auto-promotion)</p>"},{"location":"spec/language-spec/#72-comparison","title":"7.2 Comparison","text":"<p><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></p>"},{"location":"spec/language-spec/#73-logical","title":"7.3 Logical","text":"<p><code>and</code>, <code>or</code>, <code>not</code></p>"},{"location":"spec/language-spec/#74-indexing","title":"7.4 Indexing","text":"<pre><code>items[0]        # list index\nitems[-1]       # negative = from end\n\"hello\"[0]      # string index \u2192 \"h\"\nmap[\"key\"]      # map lookup\n</code></pre>"},{"location":"spec/language-spec/#75-field-access","title":"7.5 Field Access","text":"<pre><code>obj.field       # map field\ns.length        # string/list/map length\n</code></pre>"},{"location":"spec/language-spec/#8-methods","title":"8. Methods","text":""},{"location":"spec/language-spec/#81-string-methods","title":"8.1 String Methods","text":"Method Returns Example <code>.upper()</code> String <code>\"hi\".upper()</code> \u2192 <code>\"HI\"</code> <code>.lower()</code> String <code>\"HI\".lower()</code> \u2192 <code>\"hi\"</code> <code>.strip()</code> String <code>\"  hi  \".strip()</code> \u2192 <code>\"hi\"</code> <code>.contains(s)</code> Bool <code>\"hello\".contains(\"ell\")</code> \u2192 <code>true</code> <code>.starts_with(s)</code> Bool <code>\"hello\".starts_with(\"he\")</code> \u2192 <code>true</code> <code>.ends_with(s)</code> Bool <code>\"hello\".ends_with(\"lo\")</code> \u2192 <code>true</code> <code>.replace(from, to)</code> String <code>\"hello\".replace(\"l\", \"L\")</code> \u2192 <code>\"heLLo\"</code> <code>.split(delim)</code> List <code>\"a,b\".split(\",\")</code> \u2192 <code>[\"a\", \"b\"]</code> <code>.truncate(max)</code> String <code>\"hello\".truncate(3)</code> \u2192 <code>\"hel...\"</code> <code>.length</code> Int <code>\"hello\".length</code> \u2192 <code>5</code>"},{"location":"spec/language-spec/#82-list-methods","title":"8.2 List Methods","text":"Method Returns Example <code>.contains(val)</code> Bool <code>[1,2,3].contains(2)</code> \u2192 <code>true</code> <code>.join(sep)</code> String <code>[1,2].join(\"-\")</code> \u2192 <code>\"1-2\"</code> <code>.reversed()</code> List <code>[1,2,3].reversed()</code> \u2192 <code>[3,2,1]</code> <code>.length</code> Int <code>[1,2,3].length</code> \u2192 <code>3</code> <p>List concatenation: <code>[1, 2] + [3, 4]</code> \u2192 <code>[1, 2, 3, 4]</code></p>"},{"location":"spec/language-spec/#83-map-methods","title":"8.3 Map Methods","text":"Method Returns Example <code>.keys()</code> List <code>{\"a\":1}.keys()</code> \u2192 <code>[\"a\"]</code> <code>.values()</code> List <code>{\"a\":1}.values()</code> \u2192 <code>[1]</code> <code>.contains(key)</code> Bool <code>{\"a\":1}.contains(\"a\")</code> \u2192 <code>true</code> <code>.length</code> Int <code>{\"a\":1}.length</code> \u2192 <code>1</code>"},{"location":"spec/language-spec/#9-control-flow","title":"9. Control Flow","text":""},{"location":"spec/language-spec/#91-conditional","title":"9.1 Conditional","text":"<pre><code>if condition:\n    body\nelif other:\n    body\nelse:\n    body\n</code></pre>"},{"location":"spec/language-spec/#92-loops","title":"9.2 Loops","text":"<pre><code># Infinite loop \u2014 exits via break or return\nloop:\n    if done:\n        break\n\n# Bounded loop\nloop max=10:\n    response = think(response)\n    if not response[\"has_tool_calls\"]:\n        break\n</code></pre>"},{"location":"spec/language-spec/#93-for-loops","title":"9.3 For Loops","text":"<pre><code>for item in [1, 2, 3]:       # iterate list\n    write(stdout, item)\n\nfor ch in \"hello\":            # iterate characters\n    write(stdout, ch)\n\nfor key in {\"a\": 1, \"b\": 2}: # iterate map keys\n    write(stdout, key)\n</code></pre> <p><code>break</code> and <code>continue</code> work in both <code>loop</code> and <code>for</code>.</p>"},{"location":"spec/language-spec/#94-trycatch","title":"9.4 Try/Catch","text":"<pre><code>try:\n    content = read(file(\"data.txt\"))\ncatch err:\n    content = \"default\"\n    write(stdout, f\"Warning: {err}\")\n</code></pre> <ul> <li><code>err</code> variable is optional \u2014 omit it with just <code>catch:</code></li> <li>Error message is bound as a String</li> <li>Variables set in the try block are visible after it (if no error)</li> </ul>"},{"location":"spec/language-spec/#95-pass","title":"9.5 Pass","text":"<pre><code>flow placeholder():\n    pass\n</code></pre> <p>No-op statement for empty blocks.</p>"},{"location":"spec/language-spec/#10-string-interpolation","title":"10. String Interpolation","text":"<pre><code>name = \"World\"\nwrite(stdout, f\"Hello, {name}!\")        # \u2192 Hello, World!\nwrite(stdout, f\"{1 + 2} items\")        # \u2192 3 items\nwrite(stdout, f\"{name.length} chars\")  # \u2192 5 chars\n</code></pre> <p>Any valid expression can appear inside <code>{}</code>.</p>"},{"location":"spec/language-spec/#11-comments","title":"11. Comments","text":"<pre><code># This is a comment\nx = 42  # end-of-line comment\n</code></pre>"},{"location":"spec/language-spec/#12-grammar-peg","title":"12. Grammar (PEG)","text":"<pre><code>Program &lt;- Import* TypeDef* Flow*\n\nImport &lt;- \"import\" StringLiteral NEWLINE\n\nTypeDef &lt;- StructDef | EnumDef\nStructDef &lt;- \"type\" Identifier \":\" NEWLINE INDENT TypeField* DEDENT\nEnumDef &lt;- \"type\" Identifier \":\" StringLit (\"|\" StringLit)*\nTypeField &lt;- Identifier \"?\"? \":\" Type NEWLINE\n\nFlow &lt;- \"flow\" Identifier \"(\" ParameterList? \")\" (\"-&gt;\" Type)? \":\" NEWLINE INDENT Statement* DEDENT\n\nParameterList &lt;- Parameter (\",\" Parameter)*\nParameter &lt;- Identifier \":\" Type\nType &lt;- Identifier (\"[\" Type (\",\" Type)* \"]\")?\n\nStatement &lt;- Assignment / ReturnStatement / IfStatement /\n             LoopStatement / ForStatement / TryCatchStatement /\n             BreakStatement / ContinueStatement /\n             PassStatement / ExprStatement\n\nAssignment &lt;- Identifier \"=\" Expression NEWLINE\nReturnStatement &lt;- \"return\" Expression NEWLINE\nPassStatement &lt;- \"pass\" NEWLINE\nBreakStatement &lt;- \"break\" NEWLINE\nContinueStatement &lt;- \"continue\" NEWLINE\nExprStatement &lt;- Expression NEWLINE\n\nTryCatchStatement &lt;- \"try\" \":\" Block \"catch\" Identifier? \":\" Block\n\nExpression &lt;- OrExpr\nOrExpr &lt;- AndExpr (\"or\" AndExpr)*\nAndExpr &lt;- Comparison (\"and\" Comparison)*\nComparison &lt;- Addition (CompOp Addition)*\nCompOp &lt;- \"==\" / \"!=\" / \"&lt;\" / \"&gt;\" / \"&lt;=\" / \"&gt;=\"\nAddition &lt;- Multiplication ((\"+\" / \"-\") Multiplication)*\nMultiplication &lt;- Unary ((\"*\" / \"/\") Unary)*\nUnary &lt;- \"not\" Unary / \"-\" Unary / Postfix\nPostfix &lt;- Primary ((\".\" Identifier (\"(\" ArgList? \")\")?) / (\"[\" Expression \"]\") / (\"(\" ArgList? \")\"))*\nPrimary &lt;- Identifier / FStringLiteral / StringLiteral / IntLiteral / FloatLiteral /\n           BoolLiteral / ListLiteral / MapLiteral / \"(\" Expression \")\"\n\nArgList &lt;- Argument (\",\" Argument)*\nArgument &lt;- (Identifier \"=\")? Expression\n\nIfStatement &lt;- \"if\" Expression \":\" Block (\"elif\" Expression \":\" Block)* (\"else\" \":\" Block)?\nLoopStatement &lt;- \"loop\" (\"max=\" IntLiteral)? \":\" Block\nForStatement &lt;- \"for\" Identifier \"in\" Expression \":\" Block\n\nBlock &lt;- NEWLINE INDENT Statement* DEDENT\n\nIdentifier &lt;- [a-zA-Z_] [a-zA-Z0-9_]*\nStringLiteral &lt;- '\"' [^\"]* '\"'\nFStringLiteral &lt;- 'f\"' (FStringChar / '{' Expression '}')* '\"'\nIntLiteral &lt;- [0-9]+\nFloatLiteral &lt;- [0-9]+ \".\" [0-9]+\nBoolLiteral &lt;- \"true\" / \"false\"\nListLiteral &lt;- \"[\" (Expression (\",\" Expression)*)? \"]\"\nMapLiteral &lt;- \"{\" (StringLiteral \":\" Expression (\",\" StringLiteral \":\" Expression)*)? \"}\"\n</code></pre>"},{"location":"spec/language-spec/#13-cli","title":"13. CLI","text":"<pre><code>cognos run [flags] &lt;file.cog&gt;           # run a program\ncognos test &lt;file.cog&gt; --env &lt;mock&gt;     # test with mock environment\ncognos parse &lt;file.cog&gt;                 # pretty-print parsed AST\ncognos tokens &lt;file.cog&gt;               # show raw tokens\ncognos repl                            # interactive REPL\n</code></pre>"},{"location":"spec/language-spec/#flags","title":"Flags","text":"Flag Description <code>--allow-shell</code> Enable <code>__exec_shell__()</code> <code>--trace &lt;path&gt;</code> Write JSONL trace events to file <code>--trace-level metrics\\|full</code> Trace detail (default: metrics) <code>--env &lt;mock.json&gt;</code> Mock environment (for <code>cognos test</code>) <code>-v</code> / <code>-vv</code> / <code>-vvv</code> Log verbosity <p>Env var: <code>COGNOS_LOG=info|debug|trace</code></p>"},{"location":"spec/language-spec/#14-error-system","title":"14. Error System","text":"<p>Every token has a specific, context-aware error message with optional hints:</p> <pre><code>Error: unexpected '=' \u2014 not a valid expression\n  hint: did you mean '==' for comparison?\n\nError: 'let' is not needed \u2014 just write: name = value\n\nError: cannot String + Int \u2014 String + Int not supported\n</code></pre>"},{"location":"spec/language-spec/#15-environments","title":"15. Environments","text":"<p>All I/O is routed through an <code>Env</code> trait. The interpreter never calls OS functions directly.</p> Environment Usage <code>RealEnv</code> Default \u2014 real stdin/stdout, files, shell, LLM, HTTP <code>MockEnv</code> <code>cognos test --env mock.json</code> \u2014 canned responses, no network <p>See Environments docs for mock file format.</p>"},{"location":"spec/language-spec/#16-concurrency","title":"16. Concurrency","text":""},{"location":"spec/language-spec/#parallel-blocks","title":"<code>parallel:</code> Blocks","text":"<p>Run multiple statements concurrently. All branches execute in parallel threads and the block waits for all to complete before continuing.</p> <pre><code>parallel:\n    branch:\n        code = read(file(\"src/main.rs\"))\n        review = think(code, model=\"claude-sonnet-4-20250514\")\n    branch:\n        tests = shell(\"cargo test 2&gt;&amp;1\")\n        analysis = think(tests, system=\"Analyze\")\n    branch:\n        metrics = shell(\"tokei src/\")\n# review, analysis, metrics all available here\n</code></pre> <p>Each <code>branch:</code> is an indented block of N statements. All branches run concurrently.</p> <p>Semantics: - Each <code>branch:</code> block runs in its own OS thread - Block waits for ALL branches to complete - Variables assigned inside branches are available after the parallel block - No shared mutable state between branches \u2014 each gets a snapshot of current vars - Errors in any branch propagate after all branches finish</p>"},{"location":"spec/language-spec/#async-await","title":"<code>async</code> / <code>await</code>","text":"<p>Fire-and-forget with later collection. <code>async</code> starts an expression in a background thread and returns a future handle. <code>await(handle)</code> blocks until the result is ready.</p> <pre><code>handle = async deep_research(\"quantum computing\")\n# do other work while deep_research runs...\nquick = think(\"what's 2+2?\")\n# now collect the result\nresult = await(handle)\n</code></pre> <p>Semantics: - <code>async expr</code> spawns <code>expr</code> evaluation in a background thread, returns a <code>Future</code> handle - <code>await(handle)</code> blocks until the async operation completes, returns the result - The handle is a <code>Future</code> value \u2014 can be stored in variables, passed around - Each <code>await</code> consumes the handle \u2014 awaiting the same handle twice is an error - The background thread gets a snapshot of current variables and environment</p>"}]}